/**
* @class
* @classdesc Represents a 4-dimensional vector.
* @param {Number} x The x component.
* @param {Number} y The y component.
* @param {Number} z The z component.
* @param {Number} w The w component.
*/
var Vector4 = function (x,y,z,w){
    this.x = x;
    this.y = y;
    this.z = z;
    this.w = w;
};

//----------------------------------------------------------------------

/**
* Returns an array representation of the vector.
* @returns {Array} An array representation of the vector.
*/
Vector4.prototype.toArray = function (){
    var array = new Array(4);
    array[0] = this.x;
    array[1] = this.y;
    array[2] = this.z;
    array[3] = this.w;
    return array;
};

//----------------------------------------------------------------------

/**
* Sets the vector from an array.
* @param {Array} array The original array.
* @returns {Vector4} this.
*/
Vector4.prototype.fromArray = function (array){
    this.x = array[0];
    this.y = array[1];
    this.z = array[2];
    this.w = array[3];

    return this;
};

//----------------------------------------------------------------------

/**
* Sets the vector from another vector.
* @param {Vector4} vec The original vector.
* @returns {Vector4} this.
*/
Vector4.prototype.set = function (vec){
    this.x = vec.x;
    this.y = vec.y;
    this.z = vec.z;
    this.w = vec.w;

    return this;
};

//----------------------------------------------------------------------

/**
* Return a copy of this vector.
* @returns {Vector4} The copy of this vector.
*/
Vector4.prototype.cpy = function (){
    return new Vector4(this.x, this.y, this.z, this.w);
};

//----------------------------------------------------------------------

/**
* Return the length of this vector.
* @returns {Number} The length of this vector.
*/
Vector4.prototype.len = function (){
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return Math.sqrt((x*x) + (y*y) + (z*z));
};

//----------------------------------------------------------------------

/**
* Return the maximum value in this vector.
* @returns {Number} The maximum value in this vector.
*/
Vector4.prototype.max = function (){
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return Math.max(x , Math.max(y , z));
};

//----------------------------------------------------------------------

/**
* Divide this vector by a scalar.
* @returns {Vector4} this.
*/
Vector4.prototype.min = function (){
    var x = this.x;
    var y = this.y;
    var z = this.z;

    return Math.min(x , Math.min(y , z));
};

//----------------------------------------------------------------------

/**
* Add a vector to this vector.
* @returns {Vector4} this.
*/
Vector4.prototype.add = function (vec){
    this.x = this.x + vec.x;
    this.y = this.y + vec.y;
    this.z = this.z + vec.z;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Subtract a vector to this vector.
* @returns {Vector4} this.
*/
Vector4.prototype.sub = function (vec){
    this.x = this.x - vec.x;
    this.y = this.y - vec.y;
    this.z = this.z - vec.z;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Add a scalar to all the components of this vector.
* @returns {Vector4} this.
*/
Vector4.prototype.addScl = function (v){
    this.x = this.x + v;
    this.y = this.y + v;
    this.z = this.z + v;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Subtract a scalar to all the components of this vector.
* @returns {Vector4} this.
*/
Vector4.prototype.subScl = function (v){
    this.x = this.x - v;
    this.y = this.y - v;
    this.z = this.z - v;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Multiply this vector by other vector.
* @returns {Vector4} this.
*/
Vector4.prototype.mul = function (vec){
    this.x = this.x*vec.x;
    this.y = this.y*vec.y;
    this.z = this.z*vec.z;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Multiply this vector by a scalar.
* @returns {Vector4} this.
*/
Vector4.prototype.mulScl = function (value){
    this.x = this.x*value;
    this.y = this.y*value;
    this.z = this.z*value;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Divide this vector by other vector.
* @returns {Vector4} this.
*/
Vector4.prototype.div = function (vec){
    this.x = this.x/vec.x;
    this.y = this.y/vec.y;
    this.z = this.z/vec.z;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Divide this vector by a scalar.
* @returns {Vector4} this.
*/
Vector4.prototype.divScl = function (value){
    this.x = this.x/value;
    this.y = this.y/value;
    this.z = this.z/value;
    this.w = 0;

    return this;
};

//----------------------------------------------------------------------

/**
* Return the dot product between this vector and other vector.
* @param {Vector4} vec The other vector.
* @returns {Number} The dot product between this vector and other vector..
*/
Vector4.prototype.dot = function (vec){
  var x1 = this.x;
  var y1 = this.y;
  var z1 = this.z;

  var x2 = vec.x;
  var y2 = vec.y;
  var z2 = vec.z;

  return x1*x2 + y1*y2 + z1*z2;
};

//----------------------------------------------------------------------

/**
* Calculates the cross product between this vector and other vector.
* @param {Vector4} vec The other vector.
* @returns {Vector4} this.
*/
Vector4.prototype.cross = function (vec){

  var x1 = this.x;
  var y1 = this.y;
  var z1 = this.z;

  var x2 = vec.x;
  var y2 = vec.y;
  var z2 = vec.z;

  this.x = y1 * z2 - z1 * y2;
	this.y = z1 * x2 - x1 * z2;
	this.z = x1 * y2 - y1 * x2;
  this.w = 0;

  return this;
};

//----------------------------------------------------------------------

/**
* Returns the angle in degrees relative to other vector.
* @param {Vector4} vec The other vector.
* @returns {Number} The angle in degrees relative to other vector.
*/
Vector4.prototype.ang = function (vec){
    var dot = this.dot(vec);

    var len1 = this.len();
    var len2 = vec.len();

    var cos = (dot/(len1*len2));

    return Math.acos(cos);
};

//----------------------------------------------------------------------

/**
* Normalize this vector.
* @returns {Vector4} this.
*/
Vector4.prototype.nor = function (){

    var len = this.len();

    if(len > 0){
        this.x = this.x/len;
        this.y = this.y/len;
        this.z = this.z/len;
        this.w = this.w/len;
    }

    return this;
};

//----------------------------------------------------------------------

/**
* Returns the distance between this vector and other vector.
* @param {Vector4} vec The other vector.
* @returns {Number} The distance between this vector and other vector.
*/
Vector4.prototype.dst = function (vec){

    var deltaX = vec.x-this.x;
    var deltaY = vec.y-this.y;
    var deltaZ = vec.z-this.z;

    return Math.sqrt( (deltaX*deltaX) + (deltaY*deltaY) + (deltaZ*deltaZ) );
};

//----------------------------------------------------------------------

/**
* Test if this vector is equal to the other vector.
* @param {Vector4} vec The other vector.
* @returns {boolean} this True if this vector is equal to the other vector.
*/
Vector4.prototype.equals = function(vec){
    return (this.x === vec.x) &&
        (this.y === vec.y) &&
        (this.z === vec.z);
};

//----------------------------------------------------------------------

/**
* Test if this vector is equal to the other vector, whit an epsilon error.
* @param {Vector4} vec The other vector.
* @param {Number} epsilon The error.
* @returns {boolean} this True if this vector is equal to the other vector, whit an epsilon error.
*/
Vector4.prototype.epsilonEquals = function(vec,epsilon){
    // Points are equal if each component is within 'epsilon' of each other
    if( (Math.abs(this.x - vec.x) <= epsilon) &&
        (Math.abs(this.y - vec.y) <= epsilon) &&
        (Math.abs(this.z - vec.z) <= epsilon) )
        return true;
    else
        return false;
};

//----------------------------------------------------------------------
/**
* @class
* @extends {Vector4}
* @classdesc Represents a 3-dimensional vector.
* @param {Number} x The x component.
* @param {Number} y The y component.
* @param {Number} z The z component.
*/
var Vector3 = function (x,y,z){
    Vector4.call(this,x,y,z,0);
};

Vector3.prototype = new Vector4();
Vector3.prototype.constructor = Vector3;

//----------------------------------------------------------------------
/**
* @class
* @extends {Vector3}
* @classdesc Represents a 2-dimensional vector.
* @param {Number} x The x component.
* @param {Number} y The y component.
*/
var Vector2 = function (x,y){
    Vector3.call(this,x,y,0);
};

Vector2.prototype = new Vector3();
Vector2.prototype.constructor = Vector2;

//----------------------------------------------------------------------
/**
* @class
* @classdesc Represents a row-major 4x4 matrix.
* @param {Vector4} row0 The 1st row.
* @param {Vector4} row1 The 2nd row.
* @param {Vector4} row2 The 3rd row.
* @param {Vector4} row3 The 4th row.
*/
var Matrix4 = function (row0,row1,row2,row3){
    this.data = new Array(16);
    this.transposed = null;
    this.setRows(row0, row1, row2, row3);


    // REMEMBER
    // WebGL uses column-major ordering (transposed)
    // a webGL matrix : [ [column 0] [column 1] [column 2] [column 3] ]

    // Matrix4.js matrices : [ [row 0] [row 1] [row 2] [row 3] ]

    /*
        ROW-MAJOR ORDERING:

        row 0 | a b c d |
        row 1 | e f g h |
        row 2 | i j k l |
        row 3 | m n o p |

        COLUMN-MAJOR ORDERING:

        column 0 | a e i m |
        column 1 | b f j n |
        column 2 | c g k o |
        column 3 | d h l p |

    */
};

//----------------------------------------------------------------------

/**
* Returns an array that contains the matrix data.
* @returns {Array} An array that contains the matrix data.
*/
Matrix4.prototype.getData = function (){
	return this.data;
};

//----------------------------------------------------------------------

/**
* Sets the internal data array.
* @param {Array} data The data array.
*/
Matrix4.prototype.setData = function (data){
	this.data = data;
};

//----------------------------------------------------------------------

/**
* Returns an element of the matrix.
* @param {Number} row The row.
* @param {Number} col The col.
* @returns {Number} An element of the matrix.
*/
Matrix4.prototype.get = function (row,col){
	return this.data[col+(4*row)];
};

//----------------------------------------------------------------------

/**
* Sets an element of the matrix.
* @param {Number} row The row.
* @param {Number} col The col.
* @param {Number} value The value of the element.
*/
Matrix4.prototype.set = function (row,col,value){
	this.data[col+(4*row)] = value;
};

//----------------------------------------------------------------------

/**
* Fill the matrix with the given rows.
* @param {Vector4} row0 The 1st row.
* @param {Vector4} row1 The 2nd row.
* @param {Vector4} row2 The 3rd row.
* @param {Vector4} row3 The 4th row.
*/
Matrix4.prototype.setRows = function (row0,row1,row2,row3){
    var rows = new Array(4);
    rows[0] = row0.toArray();
    rows[1] = row1.toArray();
    rows[2] = row2.toArray();
    rows[3] = row3.toArray();

    for (var row = 0; row < 4; row++)
        for (var col = 0; col < 4; col++)
            this.set(row,col,rows[row][col]);
};

//----------------------------------------------------------------------

/**
* Returns the transposed matrix.
* @returns {Matrix4} The transposed matrix.
*/
Matrix4.prototype.transpose = function () {

    if(this.transposed === null){
        var transposedData = new Array(16);

        for (var col = 0; col < 4; col++)
            for (var row = 0; row < 4; row++)
                transposedData[row+(4*col)] = this.get(row,col); //= rows[row][col];

        // this.data = t;

        this.transposed = Matrix4.zeros();
        this.transposed.setData(transposedData);
    }

    return this.transposed;
};

//----------------------------------------------------------------------

/**
* Multiply M1 by M2 and returns the result matrix.
* @param {Matrix4} M1 The 1st matrix.
* @param {Matrix4} M2 The 2nd matrix.
* @returns {Matrix4} The result matrix.
*/
Matrix4.mulMM = function (M1,M2){

    // The result matrix
    var result = this.zeros();

    var resultTempValue=0;

    // Matrix 1 row
    for (var i = 0; i < 4; i++) {
        // Matrix 2 column
        for (var j = 0; j < 4; j++) {

            // Result matrix column
            for (var k = 0; k < 4; k++){
                // resultTempValue += M1.data[i+(4*k)] * M2.data[k+(4*j)];
                // resultTempValue += M1.data[k+(4*i)] * M2.data[j+(4*k)];
                result.set(j,i,result.get(j,i) + M1.get(k,i) * M2.get(j,k));
            }

            // result.data[i+j*4]=resultTempValue;
            resultTempValue=0;
        }
    }

    return result;
};

//----------------------------------------------------------------------

/**
* Multiply M by v and returns the result matrix.
* @param {Matrix4} M The matrix.
* @param {Vector4} v The vector.
* @returns {Vector4} The result vector.
*/
Matrix4.mulMV = function (M,v){

    var vec = v.toArray();

    // console.log(vec);

    // The result vector
    var result = new Array(4);


    for (var row = 0; row < 4; row++){
        result[row] = 0;
        for (var col = 0; col < 4; col++)
            result[row] += M.data[row+(4*col)] * vec[col];
    }

    var vectorResult = new Vector4(0,0,0,0);
    vectorResult.fromArray(result);

    // console.log(result);

    return vectorResult;

};

//----------------------------------------------------------------------

/**
* Creates a matrix filled with 0s.
* @returns {Matrix4} The result matrix.
*/
Matrix4.zeros = function(){
    return new Matrix4(
        new Vector4(0.0,0.0,0.0,0.0),
        new Vector4(0.0,0.0,0.0,0.0),
        new Vector4(0.0,0.0,0.0,0.0),
        new Vector4(0.0,0.0,0.0,0.0));
};

//----------------------------------------------------------------------

/**
* Creates an identity matrix.
* @returns {Matrix4} The result matrix.
*/
Matrix4.identity = function(){
    return new Matrix4(
        new Vector4(1,0,0,0),
        new Vector4(0,1,0,0),
        new Vector4(0,0,1,0),
        new Vector4(0,0,0,1));
};

//----------------------------------------------------------------------

/**
* Creates a translation matrix.
* @param {Vector3} vec The translation.
* @returns {Matrix4} The result matrix.
*/
Matrix4.translation = function(vec){
    return new Matrix4(
        new Vector4(1,0,0,vec.x),
        new Vector4(0,1,0,vec.y),
        new Vector4(0,0,1,vec.z),
        new Vector4(0,0,0,1));
};

//----------------------------------------------------------------------

/**
* Creates a rotation matrix. Each component of the vector represents an axis (x,y,z),
* only one component must have a non-zero value. The other two must be zero.
* @param {Vector3} vec The rotation.
* @returns {Matrix4} The result matrix.
*/
Matrix4.rotation = function(vec){
    var result = Matrix4.identity();

    if(vec.x !== 0){
        var rad = vec.x*(Math.PI/180);
        result = new Matrix4(
            new Vector4(1,0,0,0),
            new Vector4(0,Math.cos(rad),-Math.sin(rad),0),
            new Vector4(0,Math.sin(rad),Math.cos(rad),0),
            new Vector4(0,0,0,1));
    }else if(vec.y !== 0){
        var rad = vec.y*(Math.PI/180);
        result = new Matrix4(
            new Vector4(Math.cos(rad),0,Math.sin(rad),0),
            new Vector4(0,1,0,0),
            new Vector4(-Math.sin(rad),0,Math.cos(rad),0),
            new Vector4(0,0,0,1));
    }else if(vec.z !== 0){
        var rad = vec.z*(Math.PI/180);
        result = new Matrix4(
            new Vector4(Math.cos(rad),-Math.sin(rad),0,0),
            new Vector4(Math.sin(rad),Math.cos(rad),0,0),
            new Vector4(0,0,1,0),
            new Vector4(0,0,0,1));
    }

    return result;
};

//----------------------------------------------------------------------

/**
* Creates a scale matrix.
* @param {Vector3} vec The scales.
* @returns {Matrix4} The result matrix.
*/
Matrix4.scale = function(vec){
    return new Matrix4(
        new Vector4(vec.x,0,0,0),
        new Vector4(0,vec.y,0,0),
        new Vector4(0,0,vec.z,0),
        new Vector4(0,0,0,1));
};

//----------------------------------------------------------------------

/**
* Creates an ortographic projection matrix.
* @param {Number} left The left value.
* @param {Number} right The right value.
* @param {Number} bottom The bottom value.
* @param {Number} top The top value.
* @param {Number} near The near value.
* @param {Number} far The far value.
* @returns {Matrix4} The result matrix.
*/
Matrix4.ortho = function(left, right, bottom, top, near, far){
    return new Matrix4(
        new Vector4(2.0/(right-left),0.0,0.0,-((right+left)/(right-left))),
        new Vector4(0.0,2.0/(top-bottom),0.0,-((top+bottom)/(top-bottom))),
        new Vector4(0.0,0.0,(-2.0/(far-near)),-((far+near)/(far-near))),
        new Vector4(0.0,0.0,0.0,1.0));
};

//----------------------------------------------------------------------

/**
* Creates an perspective projection matrix.
* @param {Number} near The near value.
* @param {Number} far The far value.
* @param {Number} aspect The aspect value.
* @param {Number} fov The fov value.
* @returns {Matrix4} The result matrix.
*/
Matrix4.perspective = function(near, far, aspect, fov){

    var top = near * Math.tan((Math.PI/180)*(fov/2));
    var bottom = -top;
    var right = top*aspect;
    var left = -right;

    return new Matrix4(
        new Vector4(((2*near)/(right-left)),0,((right+left)/(right-left)),0),
        new Vector4(0,((2*near)/(top-bottom)),((top+bottom)/(top-bottom)),0),
        new Vector4(0,0,((far+near)/(far-near)),0),
        new Vector4(0,0,-1,0));
};

//----------------------------------------------------------------------

Matrix4.prototype.print = function () {
    string = "";
    for (var row = 0; row < 4; row++){
        for (var col = 0; col < 4; col++){
            string += this.data[row+(4*col)] + " ";
        }
        string += "\n";
    }

    console.log(string);
};
/**
* @class
* @classdesc Provides geometry related methods.
*/
var GeometryUtil = function () {

};

//----------------------------------------------------------------------

/**
* Returns if the rectangle contains the point.
* @param {Vector4} leftTopVertex The leftTopVertex of the rectangle.
* @param {Number} width The width of the rectangle.
* @param {Number} height The height of the rectangle.
* @param {Number} point The point.
* @returns {Boolean} True if the rectangle contains the point.
*/
GeometryUtil.testRectanglePoint = function(leftTopVertex,width,height,point){
	return (leftTopVertex.x <= point.x && leftTopVertex.y >= point.y &&
	leftTopVertex.x + width >= point.x && leftTopVertex.y - height <= point.y);
};

//----------------------------------------------------------------------

/**
* Returns if the spheres are colliding.
* @param {Vector4} centerA The center of the A sphere.
* @param {Vector4} radiusA The radius of the A sphere.
* @param {Number} centerB The center of the B sphere.
* @param {Number} radiusB The radius of the B sphere.
* @returns {Boolean} True if the spheres are colliding.
*/
GeometryUtil.testSphereSphere = function(centerA, centerB, radiusA, radiusB){
	var distance = centerA.dst(centerB);
	return (distance <= radiusA+radiusB);
};

//----------------------------------------------------------------------

/**
* Returns the middle point.
* @param {Vector4} a The a point.
* @param {Vector4} b The b point.
* @returns {Vector4} The middle point.
*/
GeometryUtil.midPoint = function(a,b){
	return new Vector3((a.x+b.x)/2.0, (a.y+b.y)/2.0, (a.z+b.z)/2.0 );
};

//----------------------------------------------------------------------

/**
* Returns the closest point in a segment to the point p.
* @param {Vector4} p The p point.
* @param {Vector4} a The a point of the segment.
* @param {Vector4} b The b point of the segment.
* @returns {Vector4} The closest point.
*/
GeometryUtil.closestPointInSegment = function (p,a,b){

	var closest = null;

	var subVector = b.cpy().sub(a);

  if ((subVector.x === 0) && (subVector.y === 0) && (subVector.z === 0)){
      // It's a point not a line segment.
			// return P.sub(A).len();

			return a;
  }

  // Calculate the t that minimizes the distance.
	// Perpendicular Distance from a Point to a Line.
  // var t = ((p.x - a.x) * dx + (p.y - a.y) * dy + (p.z - a.z) * dz) /
  //     (dx * dx + dy * dy + dz * dz);

	var t = p.cpy().sub(a).dot(subVector)/(subVector.dot(subVector));

  // See if this represents one of the segment's
  // end points or a point in the middle.
  if (t < 0){
		closest = a;
  }else if (t > 1){
		closest = b;
  }else{
    closest = a.cpy().add(subVector.mulScl(t));
  }

	return closest;
};

//----------------------------------------------------------------------

/**
* Returns the squared distance between a point and a segment.
* @param {Vector4} p The p point.
* @param {Vector4} a The a point of the segment.
* @param {Vector4} b The b point of the segment.
* @returns {Number} The squared distance.
*/
GeometryUtil.sqDistanceToSegment = function (p,a,b){

	var closest = GeometryUtil.closestPointInSegment(p,a,b);

	var subVector = p.cpy().sub(closest);

  // return (dx * dx + dy * dy + dz * dz);
	return (subVector.dot(subVector));

};

//----------------------------------------------------------------------

/**
* Returns the distance between a point and a segment.
* @param {Vector4} p The p point.
* @param {Vector4} a The a point of the segment.
* @param {Vector4} b The b point of the segment.
* @returns {Number} The distance.
*/
GeometryUtil.distanceToSegment = function (p,a,b){
	return Math.sqrt(GeometryUtil.sqDistanceToSegment(p,a,b));
};

//----------------------------------------------------------------------

/**
* Returns the closest point in a sphere to the point p.
* @param {Vector4} p The p point.
* @param {Vector4} center The center of the sphere.
* @param {Number} b The radius of the sphere.
* @returns {Vector4} The closest point.
*/
GeometryUtil.closestPointInSphere = function (p,center,radius){
	var pToCenter = p.cpy().sub(center);

	var radiusVector = pToCenter.nor().mulScl(radius); // vector with length = radius

	var closestPoint = center.cpy().add(radiusVector);

	return closestPoint;
};
var Color = function (r,g,b,a) {
  // this.vec = new Vector4(r,g,b,a);

  this.r = r;
  this.g = g;
  this.b = b;
  this.a = a;
};

Color.NONE = new Color(0.0, 0.0, 0.0, 0.0);
Color.RED = new Color(1.0, 0.0, 0.0, 1.0);
Color.GREEN = new Color(0.0, 1.0, 0.0, 1.0);
Color.BLUE = new Color(0.0, 0.0, 1.0, 1.0);

//----------------------------------------------------------------------

Color.random = function () {
  var r = Math.random();
  var g = Math.random();
  var b = Math.random();
  // var a = Math.Random();

  return new Color(r,g,b,1.0);
};

//----------------------------------------------------------------------

Color.prototype.toArray = function(){
  // return this.vec.toArray;
  var array = new Array(4);
  array[0] = this.r;
  array[1] = this.g;
  array[2] = this.b;
  array[3] = this.a;
  return array;
};


//----------------------------------------------------------------------

Color.prototype.equals = function(otherColor){
  // return this.vec.equals(otherColor.vec);
  return (this.r === vec.r) &&
      (this.g === vec.g) &&
      (this.b === vec.b) &&
      (this.a === vec.a);
};

//----------------------------------------------------------------------
var Texture = function (name,data){
  this.name = name;
  this.data = data;
};

//----------------------------------------------------------------------

Texture.prototype.getData = function (){
	return this.data;
};

//----------------------------------------------------------------------

Texture.prototype.getName = function (){
	return this.name;
};

//----------------------------------------------------------------------

Texture.prototype.getWidth = function (){
	return this.data.width;
};

//----------------------------------------------------------------------

Texture.prototype.getHeight = function (){
	return this.data.height;
};

//----------------------------------------------------------------------
var RenderContext = function (){
  this.lights = null;
  this.camera = null;
};

//----------------------------------------------------------------------

RenderContext.prototype.getLights = function (){
	return this.lights;
};

//----------------------------------------------------------------------

RenderContext.prototype.setLights = function (lights){
	this.lights=lights;
};

//----------------------------------------------------------------------

RenderContext.prototype.getCamera = function (){
	return this.camera;
};

//----------------------------------------------------------------------

RenderContext.prototype.setCamera = function (camera){
	this.camera=camera;
};

//----------------------------------------------------------------------
var Shader = function (){
    this.programID = gl.createProgram();
    this.vertShaderID = 0;
    this.fragShaderID = 0;
    this.compiled = false;
};

Shader.defaultShader = null;
Shader.debugShader = null;


// SHADERS

Shader.vs =
"uniform mat4 projectionMatrix;"+
"uniform mat4 viewMatrix;"+
"uniform mat4 transformationMatrix;"+

"attribute vec4 position;"+
"attribute vec4 color; "+ // IF A ATTRIBUTE IS NEVER USED getAttribLocation RETURNS -1 !!!
"attribute vec2 texcoord;"+

"varying lowp vec4 vColor;"+
"varying vec2 vTexcoord;"+

"void main() {"+
"  gl_Position = projectionMatrix*viewMatrix*transformationMatrix*position;"+

  // Pass the texcoord to the fragment shader.
"  vTexcoord = texcoord;"+
"  vColor = color;"+
"}";

Shader.fs=
"precision mediump float;"+

// Passed in from the vertex shader.
"varying vec2 vTexcoord;"+
"varying lowp vec4 vColor;"+
"varying lowp vec4 vAlphaColor;"+

// The texture.
"uniform int hasTexture;"+
"uniform sampler2D uSampler;"+
"uniform vec4 alphacolor;"+ // color used as transparent

"uniform float regionX;"+
"uniform float regionY;"+
"uniform float regionWidth;"+
"uniform float regionHeight;"+


"uniform float animationX;"+
"uniform float animationY;"+
"uniform float animationWidth;"+
"uniform float animationHeight;"+

"void main() {"+

"    if(hasTexture == 1){"+

"        vec2 aux_texcoord = vTexcoord;"+

"        aux_texcoord.x = aux_texcoord.x*regionWidth + regionX;"+
"        aux_texcoord.y = aux_texcoord.y*regionHeight + regionY;"+

"        aux_texcoord.x = aux_texcoord.x*animationWidth + animationX;"+
"        aux_texcoord.y = aux_texcoord.y*animationHeight + animationY;"+

"        vec4 texColor = texture2D(uSampler, aux_texcoord);"+

"        gl_FragColor = texColor + vColor;"+

"    }else{"+
"        gl_FragColor = vColor;"+
"    }"+

// Alpha

"    if(gl_FragColor.r == alphacolor.r && gl_FragColor.g == alphacolor.g && gl_FragColor.b == alphacolor.b && gl_FragColor.a == alphacolor.a){"+
"        gl_FragColor.a = 0.0;"+
"    }"+
"}";

Shader.vsDebug=
"uniform mat4 projectionMatrix;"+
"uniform mat4 viewMatrix;"+
"uniform mat4 transformationMatrix;"+

"attribute vec4 position;"+
"attribute vec4 color;"+ // // IF A ATTRIBUTE IS NEVER USED getAttribLocation RETURNS -1 !!!

"varying lowp vec4 vColor;"+

"void main() {"+
"    gl_Position = projectionMatrix*viewMatrix*transformationMatrix*position;"+
"    vColor = color;"+ // Pass the color to the fragment shader.
"}"

Shader.fsDebug=
"precision mediump float;"+

"varying lowp vec4 vColor;"+ // Passed in from the vertex shader.

"void main() {"+
"    gl_FragColor = vColor;"+
"}";

//----------------------------------------------------------------------

Shader.prototype.isCompiled = function (){
	return this.compiled;
};

//----------------------------------------------------------------------

Shader.prototype.getProgramid = function (){
	return this.programID;
};

//----------------------------------------------------------------------

Shader.prototype.setProgramid = function (programID){
	this.programID=programID;
};

//----------------------------------------------------------------------

Shader.prototype.getVertshaderid = function (){
	return this.vertShaderID;
};

//----------------------------------------------------------------------

Shader.prototype.setVertshaderid = function (vertShaderID){
	this.vertShaderID=vertShaderID;
};

//----------------------------------------------------------------------

Shader.prototype.getFragshaderid = function (){
	return this.fragShaderID;
};

Shader.prototype.setFragshaderid = function (fragShaderID){
	this.fragShaderID=fragShaderID;
};

//----------------------------------------------------------------------

// Method definition goes here.
Shader.prototype.addVertexShader = function (sourceText){

  var shaderID = gl.createShader(gl.VERTEX_SHADER);
  gl.shaderSource(shaderID,sourceText);

  this.vertShaderID = shaderID;
};

//----------------------------------------------------------------------

// Method definition goes here.
Shader.prototype.addFragmentShader = function (sourceText){

  var shaderID = gl.createShader(gl.FRAGMENT_SHADER);
  gl.shaderSource(shaderID,sourceText);

  this.fragShaderID = shaderID;
};

//----------------------------------------------------------------------

Shader.prototype.addSource = function (type,name){
  var src = document.getElementById(name).text;

  var shaderID = gl.createShader(type);
  gl.shaderSource(shaderID,src);

  if(type == gl.VERTEX_SHADER)
      this.vertShaderID = shaderID;
  else
      this.fragShaderID = shaderID;
};

//----------------------------------------------------------------------

Shader.prototype.addAttribute = function (location,name){
  gl.bindAttribLocation(this. programID, location, name);
};

//----------------------------------------------------------------------

// Method definition goes here.
Shader.prototype.addMatrix = function (matrix,name){
  matrixLocation = gl.getUniformLocation(this.programID, name);
  gl.uniformMatrix4fv(matrixLocation, false, new Float32Array(matrix.getData()));
};

//----------------------------------------------------------------------

Shader.prototype.addMatrixArray = function (matrixArray,name){
  matrixLocation = gl.getUniformLocation(this.programID, name);

  var raw = [];
  for (var m of matrixArray) {
      raw = raw.concat(matrix.getData());
  }

  gl.uniformMatrix4fv(matrixLocation, false, new Float32Array(raw));
};

//----------------------------------------------------------------------

Shader.prototype.addInt = function (value, name){
  valueLocation = gl.getUniformLocation(this.programID, name);
  gl.uniform1i(valueLocation, value);
};

//----------------------------------------------------------------------

Shader.prototype.addFloat = function (value, name){
  valueLocation = gl.getUniformLocation(this.programID, name);
  gl.uniform1f(valueLocation, value);
};

//----------------------------------------------------------------------

Shader.prototype.addFloatVector = function (value, name){
  valueLocation = gl.getUniformLocation(this.programID, name);
  gl.uniform4fv(valueLocation, new Float32Array(value));
};

//----------------------------------------------------------------------

Shader.prototype.compile = function (){
  if( ! this.isCompiled()){
    gl.compileShader(this.fragShaderID);

    var compiled = gl.getShaderParameter(this.fragShaderID, gl.COMPILE_STATUS);
    //    console.log('Shader compiled successfully: ' + compiled); // TODO uncomment console.log()
    var compilationLog = gl.getShaderInfoLog(this.fragShaderID);
    //    console.log('Shader compiler log: ' + compilationLog);

    gl.compileShader(this.vertShaderID);

    compiled = gl.getShaderParameter(this.vertShaderID, gl.COMPILE_STATUS);
    //    console.log('Shader compiled successfully: ' + compiled);
    compilationLog = gl.getShaderInfoLog(this.vertShaderID);
    //    console.log('Shader compiler log: ' + compilationLog);

    gl.attachShader(this.programID,this.fragShaderID);
    gl.attachShader(this.programID,this.vertShaderID);
    gl.linkProgram(this.programID);

    this.compiled = true;
  }
};

//----------------------------------------------------------------------

Shader.prototype.enable = function (){
  gl.useProgram(this.programID);
};

//----------------------------------------------------------------------

Shader.prototype.disable = function (){
  gl.useProgram(null);
};

//----------------------------------------------------------------------

Shader.create = function(typeStr){

  var shader = null;

  if(typeStr === 'default'){

    if(Shader.defaultShader === null){

      Shader.defaultShader = new Shader();

      Shader.defaultShader.addVertexShader(Shader.vs);
      Shader.defaultShader.addFragmentShader(Shader.fs);
      Shader.defaultShader.addAttribute(0, "position");

      //REMEMBER: IF A ATTRIBUTE IS NEVER USED getAttribLocation RETURNS -1 !!!
      Shader.defaultShader.addAttribute(2, "color");
      Shader.defaultShader.addAttribute(1, "texcoord");
    }

    shader = Shader.defaultShader;

  }else if(typeStr === 'debug'){

    if(Shader.debugShader === null){

      Shader.debugShader = new Shader();

      Shader.debugShader.addVertexShader(Shader.vsDebug);
      Shader.debugShader.addFragmentShader(Shader.fsDebug);
      Shader.debugShader.addAttribute(0, "position");

      //REMEMBER: IF A ATTRIBUTE IS NEVER USED getAttribLocation RETURNS -1 !!!
      Shader.debugShader.addAttribute(1, "color");
    }

    shader = Shader.debugShader;
  }

  return shader;
};

//----------------------------------------------------------------------
var Material = function (){
    this.texture = null;
    this.shader = null;
    this.color = Color.NONE;


};

//----------------------------------------------------------------------

Material.prototype.getTexture = function (){
	 return this.texture;
};

//----------------------------------------------------------------------

Material.prototype.setTexture = function (texture){
	 this.texture=texture;
};

//----------------------------------------------------------------------

Material.prototype.getShader = function (){
	 return this.shader;
};

//----------------------------------------------------------------------

Material.prototype.setShader = function (shader){
	 this.shader=shader;
};

//----------------------------------------------------------------------

Material.prototype.setColor = function (color){
	 this.color = color;
};

//----------------------------------------------------------------------

Material.prototype.getColor = function (){
	 return this.color;
};

//----------------------------------------------------------------------


Material.prototype.enable = function (){
  // TODO: If not texture then use color, ...

  this.shader.enable();

  this.shader.addInt(0, "thereIsTexture");

  if(this.texture !== null){
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.textureID);
      // gl.uniform1i(this.thereIsTextureUnifrom , 1);
      // gl.uniform1i(this.samplerUniform , 0);

      this.shader.addInt(1, "hasTexture");
      this.shader.addInt(0, "uSampler");

      this.reset();

  }

};

//----------------------------------------------------------------------

Material.prototype.disable = function (){

    gl.bindTexture(gl.TEXTURE_2D, null);

    this.shader.disable();
};

//----------------------------------------------------------------------

Material.prototype.reset = function (){
    this.shader.addFloat(0.0, "animationX");
    this.shader.addFloat(0.0, "animationY");
    this.shader.addFloat(1.0, "animationWidth");
    this.shader.addFloat(1.0, "animationHeight");

    this.shader.addFloat(0.0, "regionX");
    this.shader.addFloat(0.0, "regionY");
    this.shader.addFloat(1.0, "regionWidth");
    this.shader.addFloat(1.0, "regionHeight");
};

//----------------------------------------------------------------------

Material.prototype.bind = function (){
    // TODO: If non texture use shader for plain color

    this.shader = Shader.create('default');

    this.shader.compile();

    // console.log(gl.getAttribLocation(this.shader.getProgramid(), "texcoord"));
    //
    // this.thereIsTextureUnifrom = gl.getUniformLocation(this.shader.getProgramid(), "thereIsTexture");

    if(this.texture !== null){

      // this.samplerUniform = gl.getUniformLocation(this.shader.getProgramid(), "uSampler");


      this.textureID = gl.createTexture();

      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, this.textureID);
      gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);

      gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, this.texture.getData());
      //  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      //  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);

      //   gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      // gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);

      //   gl.generateMipmap(gl.TEXTURE_2D);


      // gl.NEAREST is also allowed, instead of gl.LINEAR, as neither mipmap.
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
      // Prevents s-coordinate wrapping (repeating).
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      // Prevents t-coordinate wrapping (repeating).
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      //  gl.generateMipmap(gl.TEXTURE_2D);
      gl.bindTexture(gl.TEXTURE_2D, null);

    }
};

//----------------------------------------------------------------------
var Animation = function () {
  this.frames = [];
  this.currentFrame = 0;
  this.speed = 1;
  this.lastTime = 0;

};

//----------------------------------------------------------------------

Animation.create = function (frameCount, horizontal, reverse, startPosition, width, height, speed) {

    // TODO: check if coordinates are > 1 or < 0 !!!!!

    var animation = new Animation();
    animation.setSpeed(speed);

    var horizontalDir = 0;
    var verticalDir = 0;

    if(horizontal)
      horizontalDir = 1;
    else
      verticalDir = 1;

    if(reverse){
      horizontalDir *= -1;
      verticalDir *= -1;
    }

    var start = 0;
    var end = frameCount;
    var delta = 1;

    if(reverse){
      start = frameCount-1;
      end = 0;
      delta = -1;
    }

    for (var i = start; i !== end; i+=delta) {

      var pos = new Vector2(0,0);
      pos.add(startPosition);

      if(horizontalDir !== 0)
        pos.x += i*width;

      if(verticalDir !== 0)
        pos.y += i*height;

      var frame = new AnimationFrame();
      frame.set(pos,width,height);
      animation.addFrame(frame);

    }

    return animation;
};

//----------------------------------------------------------------------

Animation.prototype.setSpeed = function (speed) {
    this.speed = speed;
};

//----------------------------------------------------------------------

Animation.prototype.addFrame = function (frame) {
    this.frames.push(frame);
};

//----------------------------------------------------------------------

Animation.prototype.getNumberOfFrames = function () {
    return this.frames.length;
};

//----------------------------------------------------------------------

Animation.prototype.getCurrentFrameNumber = function () {
    return this.currentFrame;
};

//----------------------------------------------------------------------

Animation.prototype.getNextFrame = function () {

    // this.speed -> frame/second.
    // var time -> time of one frame.

    var time = (1.0/(this.speed)); // in seconds !
    var now = Time.now(); // in seconds !

    // if delta time is greater than 'one frame time'
    // then -> change to the next frame.
    if((now-this.lastTime) >= time){
        this.lastTime = now;
        this.currentFrame = (this.currentFrame + 1)%this.frames.length;
    }

    return this.frames[this.currentFrame];
};

//----------------------------------------------------------------------
var AnimationFrame = function () {
    this.position = new Vector2(0,0);
    this.width = 1.0;
    this.height = 1.0;
};

//----------------------------------------------------------------------

AnimationFrame.prototype.set = function (position, width, height) {
    this.position = position
    this.width = width;
    this.height = height;
};

//----------------------------------------------------------------------

AnimationFrame.prototype.getPosition = function (){
	return this.position;
};

//----------------------------------------------------------------------

AnimationFrame.prototype.getWidth = function (){
	return this.width;
};

//----------------------------------------------------------------------

AnimationFrame.prototype.getHeight = function (){
	return this.height;
};

//----------------------------------------------------------------------
var Mesh = function (numVertices) {

    this.numVertices = numVertices;
    // var size = numVertices*4;

    this.vertices = [];
    this.normals = [];
    this.faces = [];
    this.texCoord = [];

    this.vIndex = 0; // Vertices index
    this.nIndex = 0; // Normals index
    this.fIndex = 0; // Face index
    this.txIndex = 0; // TexCoord index

    this.max = new Vector3(0,0,0); // store the max width, height, depth;

};

//----------------------------------------------------------------------

Mesh.prototype.addVertex = function (vec) {
    this.vertices[this.vIndex] = vec.x; this.vIndex++;
    this.vertices[this.vIndex] = vec.y; this.vIndex++;
    this.vertices[this.vIndex] = vec.z; this.vIndex++;
    this.vertices[this.vIndex] = vec.w; this.vIndex++;


    // check the max width, height, depth;

    var x = Math.abs(vec.x)*2; // width
    var y = Math.abs(vec.y)*2; // height
    var z = Math.abs(vec.z)*2; // depth

    if(x > this.max.x)
        this.max.x = x;

    if(y > this.max.y)
        this.max.y = y;

    if(z > this.max.z)
        this.max.z = z;

};

//----------------------------------------------------------------------

Mesh.prototype.addNormal = function (vec) {
    this.normals[this.nIndex] = vec.x; this.nIndex++;
    this.normals[this.nIndex] = vec.y; this.nIndex++;
    this.normals[this.nIndex] = vec.z; this.nIndex++;
    this.normals[this.nIndex] = vec.w; this.nIndex++;
};

//----------------------------------------------------------------------

Mesh.prototype.addFace = function (v1,v2,v3) {
    this.faces[this.fIndex] = v1; this.fIndex++;
    this.faces[this.fIndex] = v2; this.fIndex++;
    this.faces[this.fIndex] = v3; this.fIndex++;
};

//----------------------------------------------------------------------

Mesh.prototype.addTexCoord = function (u,v) {
    this.texCoord[this.txIndex] = u; this.txIndex++;
    this.texCoord[this.txIndex] = v; this.txIndex++;
};

//----------------------------------------------------------------------

// TODO: getCenterVertex, getMostTopVertex, getMoreLeftVertex, getMoreRightVertex, getMoreBottomVertex

Mesh.prototype.getVertex = function (index) {
    return new Vector4(this.vertices[(index*4)],this.vertices[(index*4)+1],
        this.vertices[(index*4)+2],this.vertices[(index*4)+3]);
};

//----------------------------------------------------------------------

Mesh.prototype.setVertex = function (index,vec) {
    this.vertices[(index*4)] = vec.x;
    this.vertices[(index*4)+1] = vec.y;
    this.vertices[(index*4)+2] = vec.z;
    this.vertices[(index*4)+3] = vec.w;
};

//----------------------------------------------------------------------

Mesh.prototype.getNumVertices = function () {
    return this.vertices.length/4;
};

//----------------------------------------------------------------------

Mesh.prototype.getNumFaces = function () {
    return this.faces.length/3;
};

//----------------------------------------------------------------------

Mesh.prototype.getVerticesData = function () {
    return this.vertices;
};

//----------------------------------------------------------------------

Mesh.prototype.getNormalsData = function () {
    return this.normals;
};

//----------------------------------------------------------------------

//Mesh.prototype.getColorData();
Mesh.prototype.getFacesData = function () {
    return this.faces;
};

//----------------------------------------------------------------------

Mesh.prototype.getTexCoordData = function () {
    return this.texCoord;
};

//----------------------------------------------------------------------

Mesh.prototype.hasTexture = function () {
    return this.texCoord.length > 0;
};

//----------------------------------------------------------------------

Mesh.prototype.getMax = function () {
    return this.max.cpy();
};

//----------------------------------------------------------------------

Mesh.prototype.print = function () {
    var str = "";
    for (var i = 0; i < (this.numVertices*4); i++) {
        str += this.vertices[i] + "\n";
    }

    console.log(str);
};

//----------------------------------------------------------------------
var RectangleMesh = function () {
  Mesh.call(this, 4);

  this.width = 1;
  this.height = 1;

  var w = (this.width/2.0);
  var h = (this.height/2.0);


  // Vertices
  Mesh.prototype.addVertex.call(this,new Vector4(-w, -h, 0, 1));
  Mesh.prototype.addVertex.call(this,new Vector4(w, -h, 0, 1));
  Mesh.prototype.addVertex.call(this,new Vector4(w, h, 0, 1));
  Mesh.prototype.addVertex.call(this,new Vector4(-w, h, 0, 1));

  // TexCoords
  Mesh.prototype.addTexCoord.call(this,0,0);
  Mesh.prototype.addTexCoord.call(this,1,0);
  Mesh.prototype.addTexCoord.call(this,1,1);
  Mesh.prototype.addTexCoord.call(this,0,1);

  // Faces
  Mesh.prototype.addFace.call(this,0,1,2);
  Mesh.prototype.addFace.call(this,2,3,0);

};

RectangleMesh.prototype = new Mesh();
RectangleMesh.prototype.constructor = RectangleMesh;

//----------------------------------------------------------------------
var CubeMesh = function () {
  Mesh.call(this, 24);

  var w = 1/2.0;
  var h = 1/2.0;
  var d = 1/2.0;

  // Vertices
  // Front Face
  Mesh.prototype.addVertex.call(this, new Vector4(-w, -h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, -h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(-w, h, d, 1));

  // Back face
  Mesh.prototype.addVertex.call(this, new Vector4(-w, -h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(-w, h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, -h, -d, 1));

  // Top face
  Mesh.prototype.addVertex.call(this, new Vector4(-w, h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(-w, h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, h, -d, 1));

  // Bottom face
  Mesh.prototype.addVertex.call(this, new Vector4(-w, -h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, -h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, -h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(-w, -h, d, 1));

  // Right face
  Mesh.prototype.addVertex.call(this, new Vector4(w, -h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(w, -h, d, 1));

  // Left face
  Mesh.prototype.addVertex.call(this, new Vector4(-w, -h, -d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(-w, -h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(-w, h, d, 1));
  Mesh.prototype.addVertex.call(this, new Vector4(-w, h, -d, 1));

  // TexCoords
  Mesh.prototype.addTexCoord.call(this,0.0, 1.0);
  Mesh.prototype.addTexCoord.call(this,0.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 1.0);

  Mesh.prototype.addTexCoord.call(this,0,0);
  Mesh.prototype.addTexCoord.call(this,1,0);
  Mesh.prototype.addTexCoord.call(this,1,1);
  Mesh.prototype.addTexCoord.call(this,0,1);

  Mesh.prototype.addTexCoord.call(this,0.0, 1.0);
  Mesh.prototype.addTexCoord.call(this,0.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 1.0);

  Mesh.prototype.addTexCoord.call(this,1.0, 1.0);
  Mesh.prototype.addTexCoord.call(this,0.0, 1.0);
  Mesh.prototype.addTexCoord.call(this,0.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 0.0);

  Mesh.prototype.addTexCoord.call(this,1.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 1.0);
  Mesh.prototype.addTexCoord.call(this,0.0, 1.0);
  Mesh.prototype.addTexCoord.call(this,0.0, 0.0);

  Mesh.prototype.addTexCoord.call(this,0.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 0.0);
  Mesh.prototype.addTexCoord.call(this,1.0, 1.0);
  Mesh.prototype.addTexCoord.call(this,0.0, 1.0);

  // Normals

  // Front face
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));

  // Back face
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,0,1,0));

  // Top face
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));

  // Bottom face
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(0,1,0,0));

  // Right face
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));

  // Left face
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));
  Mesh.prototype.addNormal.call(this,new Vector4(1,0,0,0));




  // Faces

  Mesh.prototype.addFace.call(this,0,1,2);
  Mesh.prototype.addFace.call(this,0,2,3);

  Mesh.prototype.addFace.call(this,4,  5,  6);
  Mesh.prototype.addFace.call(this,4,  6,  7);

  Mesh.prototype.addFace.call(this,8,  9,  10);
  Mesh.prototype.addFace.call(this,8,  10, 11);

  Mesh.prototype.addFace.call(this,12, 13, 14);
  Mesh.prototype.addFace.call(this,12, 14, 15);

  Mesh.prototype.addFace.call(this,16, 17, 18);
  Mesh.prototype.addFace.call(this,16, 18, 19);

  Mesh.prototype.addFace.call(this, 20, 21, 22);
  Mesh.prototype.addFace.call(this, 20, 22, 23);
};

CubeMesh.prototype = new Mesh();
CubeMesh.prototype.constructor = CubeMesh;
var SpriteBatch = function (material){
  this.material = material;
  this.renderers = {};
  this.renderContext = null;
  this.vboColor = 0;

};

SpriteBatch.mesh = new RectangleMesh();

SpriteBatch.vboPosition = 0;
SpriteBatch.vboElemIndices = 0;
SpriteBatch.vboTexture = 0;
SpriteBatch.vboNormal = 0;
SpriteBatch.vao = 0;

SpriteBatch.binded = false;

//----------------------------------------------------------------------

SpriteBatch.prototype.add = function (renderer){

  if( ! (renderer.getId() in this.renderers))
    this.renderers[renderer.getId()] = renderer;
};

//----------------------------------------------------------------------

SpriteBatch.prototype.bind = function (){

  this.material.bind();

  if(! SpriteBatch.binded){

    SpriteBatch.binded = true;

    // create VAO
    SpriteBatch.vao = vao_ext.createVertexArrayOES();
    vao_ext.bindVertexArrayOES(SpriteBatch.vao);


    // POSITION
    gl.enableVertexAttribArray(0);
    SpriteBatch.vboPosition = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, SpriteBatch.vboPosition);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(SpriteBatch.mesh.getVerticesData()), gl.STATIC_DRAW);
    gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);


    // TEXTURE
    gl.enableVertexAttribArray(1);
    SpriteBatch.vboTexture = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, SpriteBatch.vboTexture);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(SpriteBatch.mesh.getTexCoordData()), gl.STATIC_DRAW);
    gl.vertexAttribPointer(1, 2, gl.FLOAT, false, 0, 0);





    // NORMALS
    gl.enableVertexAttribArray(3);
    SpriteBatch.vboNormal = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, SpriteBatch.vboNormal);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array( SpriteBatch.mesh.getNormalsData()), gl.STATIC_DRAW);
    gl.vertexAttribPointer(3, 4, gl.FLOAT, false, 0, 0);


    // ELEMENTS
    SpriteBatch.vboElemIndices = gl.createBuffer();
    gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, SpriteBatch.vboElemIndices);
    gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(SpriteBatch.mesh.getFacesData()), gl.STATIC_DRAW);

    // Finised setting up VAO
    vao_ext.bindVertexArrayOES(null);

    // var children = this.getChildren();
    // for (var i = 0; i < children.length; i++) {
    // 	children[i].bind();
    // }

    }


  // COLOR
  gl.enableVertexAttribArray(2);
  this.vboColor = gl.createBuffer();
  // gl.bindBuffer(gl.ARRAY_BUFFER, this.vboColor);
  // var color = [];
  // for (var i = 0; i < SpriteBatch.mesh.getVerticesData().length/4; i++) {
  // 	color = color.concat(this.material.color.getVector().toArray(());
  // }
  // gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(color), gl.STATIC_DRAW); // TODO DYNAMIC
  // gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 0, 0);

};

//----------------------------------------------------------------------

SpriteBatch.prototype.update = function (renderContext){
  this.renderContext = renderContext;

	this.material.enable();

  // var matrices = [];
  // for (var renderer of this.renderers) {
  //     matrices.push(renderer.gameObject.getTransform().getMatrix().transpose());
  // }
  //
  // this.material.getShader().addMatrixArray(matrices, "transformationMatrix");
  //
	// // this.material.getShader().addMatrix(this.gameObject.getTransform().getMatrix().transpose(), "transformationMatrix");
	this.material.getShader().addMatrix(this.renderContext.getCamera().getProjectionMatrix()/*.transpose()*/, "projectionMatrix");
	this.material.getShader().addMatrix(this.renderContext.getCamera().getViewMatrix()/*.transpose()*/, "viewMatrix");

	this.material.disable();

	// var children = this.getChildren();
	// for (var i = 0; i < children.length; i++) {
	// 	children[i].update(renderContext);
	// }
};

//----------------------------------------------------------------------

SpriteBatch.prototype.render = function (){

  this.material.enable();

  vao_ext.bindVertexArrayOES(SpriteBatch.vao);

  gl.enableVertexAttribArray(0);

  if(SpriteBatch.mesh.hasTexture())
    gl.enableVertexAttribArray(1);

  gl.enableVertexAttribArray(3);

  var cam = this.renderContext.getCamera();

  for (var key in this.renderers) {

    var renderer = this.renderers[key];

    if(renderer.isEnabled()){

      var test = cam.getFrustum().testSphere(renderer.getGameObject().getTransform().position, renderer.getRadius());

      // console.log(renderer.getRadius());
      // console.log(test);

      if(test){


        gl.enableVertexAttribArray(2);

        gl.bindBuffer(gl.ARRAY_BUFFER, this.vboColor);
      	var color = [];
      	for (var i = 0; i < SpriteBatch.mesh.getVerticesData().length/4; i++) {
      	   color = color.concat(renderer.getMaterial().getColor().toArray());
      	}
      	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(color), gl.STATIC_DRAW);
      	gl.vertexAttribPointer(2, 4, gl.FLOAT, false, 0, 0);

        renderer.gameObject.getTransform().generateMatrix();
        this.material.getShader().addMatrix(renderer.gameObject.getTransform().getMatrix()/*.transpose()*/, "transformationMatrix");

        renderer.updateMaterial(this.material);

        gl.drawElements(gl.TRIANGLES, SpriteBatch.mesh.getNumFaces()*3, gl.UNSIGNED_SHORT, 0);

        this.material.reset();
      }
    }
  }



  gl.disableVertexAttribArray(0);
	gl.disableVertexAttribArray(1);
	gl.disableVertexAttribArray(2);
	gl.disableVertexAttribArray(3);



	this.material.disable();
};

//----------------------------------------------------------------------
var RenderEngine = function (){

  this.color = new Color(0,0,0,1);

  var canvas = document.getElementById("glcanvas");

  var realToCSSPixels = window.devicePixelRatio || 1; // FOR HD RETINA SCREEN

  // Lookup the size the browser is displaying the canvas in CSS pixels
  // and compute a size needed to make our drawingbuffer match it in
  // device pixels.
  var displayWidth  = Math.floor(canvas.clientWidth  * realToCSSPixels);
  var displayHeight = Math.floor(canvas.clientHeight * realToCSSPixels);

  canvas.width = displayWidth;
  canvas.height = displayHeight;

  gl = null;

  try {
  // Try to grab the standard context. If it fails, fallback to experimental.
  gl = canvas.getContext("webgl") || canvas.getContext("experimental-webgl");
// console.log("MAX_TEXTURE_SIZE: " + gl.getParameter(gl.MAX_TEXTURE_SIZE));
  }
  catch(e) {
    alert("Unable to initialize WebGL. Your browser may not support it.");
  }

  // If we don't have a GL context.
  if (!gl) {
    alert("Unable to initialize WebGL. Your browser may not support it.");
    gl = null;
  }

  vao_ext = gl.getExtension ("OES_vertex_array_object");
  instance_ext = gl.getExtension("ANGLE_instanced_arrays");

  if (!vao_ext) {
    alert("ERROR: Your browser does not support WebGL 'VAO' extension");
  }

  if (!instance_ext) {
    alert("ERROR: Your browser does not support WebGL 'ANGLE Instanced Rendering' extension");
  }

  // Only continue if WebGL is available and working

  if (gl) {

    //   console.log(gl.getParameter(gl.MAX_TEXTURE_SIZE));
    //   console.log(gl.DEPTH_FUNC);

    // canvas.width  = window.innerWidth;
    // canvas.height = window.innerHeight;

    // gl.viewport(0, 0, canvas.width, canvas.height);
    //   gl.viewport(0, 0, 1, 1);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
    gl.clearColor(this.color.r, this.color.g, this.color.b, this.color.a);                      // Set clear color to black, fully opaque

    gl.enable(gl.DEPTH_TEST);                               // Enable depth testing
    gl.depthFunc(gl.LEQUAL);                                // Near things obscure far things
    gl.enable(gl.CULL_FACE); // BACK by default
    gl.cullFace(gl.BACK);

    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    // gl.enable(gl.BLEND);

    //gl.enable(gl.TEXTURING);
    //gl.enable(gl.TEXTURE_2D);

    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);      // Clear the color and the depth buffer.
  }

    // this.renderers = []; // TODO: remove
    this.clear();
    // this.noTextureIndex = 1;

    DebugRenderer.init();
};

//----------------------------------------------------------------------

RenderEngine.prototype.setClearColor = function (color){
  this.color.r = color.r;
  this.color.g = color.g;
  this.color.b = color.b;
  this.color.a = color.a;

  gl.clearColor(this.color.r, this.color.g, this.color.b, this.color.a);
};

//----------------------------------------------------------------------

RenderEngine.prototype.addRenderers = function (renderers){

  for (var renderer of renderers) {

    var tex = renderer.getMaterial().getTexture();

    if(tex !== null){

      var texName = tex.getName();

      if((texName in this.textureBatches)){
          this.textureBatches[texName].add(renderer);
      }else {
          this.textureBatches[texName] = new SpriteBatch(renderer.getMaterial());
          this.textureBatches[texName].add(renderer);
      }

    }else
      this.noTextureBatch.add(renderer);

  }
};

//----------------------------------------------------------------------

RenderEngine.prototype.clear = function (){
  this.textureBatches = {};
  this.noTextureBatch = new SpriteBatch(new Material());
  this.renderContext = null;
};

//----------------------------------------------------------------------

RenderEngine.prototype.getRenderContext = function (){
	return this.renderContext;
};

//----------------------------------------------------------------------

RenderEngine.prototype.setRenderContext = function (renderContext){
	this.renderContext=renderContext;
};

//----------------------------------------------------------------------

RenderEngine.prototype.update = function (){

  // RE-BUILD frustum
  this.renderContext.getCamera().getFrustum().build();

  // for (var renderer of this.renderers)
  //     renderer.update(this.renderContext);

  for (var i in this.textureBatches)
    this.textureBatches[i].update(this.renderContext);


  this.noTextureBatch.update(this.renderContext);

  DebugRenderer.update(this.renderContext);

};

//----------------------------------------------------------------------

RenderEngine.prototype.bind = function (){

  // for (var renderer of this.renderers){
  //     renderer.bind();
  // }


  // TODO IF there are new batches THEN bind !!!!

  for (var i in this.textureBatches)
    this.textureBatches[i].bind();

  this.noTextureBatch.bind();
};

//----------------------------------------------------------------------

RenderEngine.prototype.render = function (){


  // for (var renderer of this.renderers){
  //     renderer.render();
  // }

  // TODO: culling ????


  for (var i in this.textureBatches){
    // console.log(this.batches[i].material.texture.name);
    this.textureBatches[i].render();
  }


  this.noTextureBatch.render();


  for (var renderer of DebugRenderer.getRenderers()){
    renderer.bind();
    renderer.render();
  }

  DebugRenderer.clear();

};

//----------------------------------------------------------------------
var DebugRenderer = function (){
};

DebugRenderer.shader = null;
DebugRenderer.transformationMatrix = Matrix4.identity();

DebugRenderer.list = [];

//----------------------------------------------------------------------

DebugRenderer.getRenderers = function () {
    return DebugRenderer.list;
};

//----------------------------------------------------------------------

DebugRenderer.clear = function () {
    DebugRenderer.list = [];
};

//----------------------------------------------------------------------

DebugRenderer.init = function() {
    DebugRenderer.shader = Shader.create('debug');

    DebugRenderer.shader.compile();
};

//----------------------------------------------------------------------

DebugRenderer.setTransformationMatrix = function (matrix) {
    if(matrix === null)
        DebugRenderer.transformationMatrix = Matrix4.identity();
    else
        DebugRenderer.transformationMatrix = matrix;
};

//----------------------------------------------------------------------

DebugRenderer.update = function (renderContext) {
	DebugRenderer.shader.enable();

	// // Camera matrix
	// glm::mat4 view = glm::lookAt(
	// 	glm::vec3(4,3,3), // Camera is at (4,3,3), in World Space
	// 	glm::vec3(0,0,0), // and looks at the origin
	// 	glm::vec3(0,1,0)  // Head is up (set to 0,-1,0 to look upside-down)
	// );

	// TODO fail --> this.gameObject.getScene().getCamera();

	// if(this.gameObject.getTransform().hasChanged()){
	//
	// }

	DebugRenderer.shader.addMatrix(renderContext.getCamera().getProjectionMatrix().transpose(), "projectionMatrix");
	// this.material.getShader().addMatrix(Matrix4.identity(), "viewMatrix");
	DebugRenderer.shader.addMatrix(renderContext.getCamera().getViewMatrix().transpose(), "viewMatrix");

	DebugRenderer.shader.disable();

};

//----------------------------------------------------------------------

DebugRenderer.drawLine = function (start,end,color){

    DebugRenderer.list.push(new LineRenderer(DebugRenderer.shader,start,end,color,this.transformationMatrix));
};

//----------------------------------------------------------------------
var BaseObject = function (){
    this.id = BaseObject.lastId;
    BaseObject.lastId++;
};

BaseObject.lastId = 0;

//----------------------------------------------------------------------

BaseObject.prototype.getId = function (){
	return this.id;
};

//----------------------------------------------------------------------
var GameObject = function (){
    BaseObject.call(this);
    this.parent = null;
    this.children = [];
    this.components = [];
    this.scene = null;
    this.static = false;

    this.transform = null;
};

GameObject.prototype = new BaseObject();
GameObject.prototype.constructor = GameObject;

//----------------------------------------------------------------------

GameObject.prototype.getTransform = function (){
	return this.transform;
};

//----------------------------------------------------------------------

GameObject.prototype.getParent = function (){
	return this.parent;
};

//----------------------------------------------------------------------

GameObject.prototype.setParent = function (parent){
	this.parent=parent;
};

//----------------------------------------------------------------------

GameObject.prototype.setStatic = function (bool){
	this.static = bool;
};

//----------------------------------------------------------------------

GameObject.prototype.isStatic = function (parent){
	return this.static;
};

//----------------------------------------------------------------------

GameObject.prototype.getScene = function (){
	return this.scene;
};

//----------------------------------------------------------------------

GameObject.prototype.setScene = function (scene){
	this.scene=scene;
};

//----------------------------------------------------------------------

GameObject.prototype.getChildren = function (){
	return this.children;
};

//----------------------------------------------------------------------

GameObject.prototype.setChildren = function (children){
    for (var child of children) {
        child.setParent(this);
    }

	this.children=children;
};

//----------------------------------------------------------------------

GameObject.prototype.getComponents = function (){
	return this.components;
};

//----------------------------------------------------------------------

GameObject.prototype.enable = function (){
	for (var component of this.components) {
    component.enable();
  }
};

//----------------------------------------------------------------------

GameObject.prototype.disable = function (){
  for (var component of this.components) {
    component.disable();
  }
};

//----------------------------------------------------------------------

GameObject.prototype.addChild = function (child){
  child.setParent(this);
  this.children.push(child);
};

//----------------------------------------------------------------------

GameObject.prototype.getChild = function (){

};

//----------------------------------------------------------------------

GameObject.prototype.addComponent = function (component){

  if( (component instanceof Transform) && (this.transform === null)){

    this.transform = component;

    component.setGameObject(this);
    this.components.push(component);
  }else {
    component.setGameObject(this);
    this.components.push(component);
  }

};

//----------------------------------------------------------------------

GameObject.prototype.getAllComponents = function (componentClass){

    var componentList = [];

    component = this.getComponent(componentClass);

    if(component !== null)
      componentList.push(component);

    for (var child of this.children) {
        // var component = child.getComponent(componentClass);
        //
        // if(component != null)
        //   componentList.push(component);

        componentList = componentList.concat(child.getAllComponents(componentClass));
    }



    return componentList;

};

//----------------------------------------------------------------------

GameObject.prototype.getComponent = function (componentClass){

    for (var component of this.components) {

        if(component instanceof componentClass){
            return component;
        }
    }

    return null;
};

//----------------------------------------------------------------------

GameObject.prototype.getComponentsInChildren = function (componentClass){
    var componentList = [];

    for (var child of this.children) {
        componentList = componentList.concat(child.getAllComponents(componentClass));
    }

    return componentList;
};

//----------------------------------------------------------------------

GameObject.prototype.delete = function (){
  this.disable();
	this.scene.deleteObject(this);
};

//----------------------------------------------------------------------
var Component = function (){
    BaseObject.call(this);
    this.gameObject = null;
    this.enabled = true;
};

Component.prototype = new BaseObject();
Component.prototype.constructor = Component;

//----------------------------------------------------------------------

Component.prototype.getGameObject = function (){
	return this.gameObject;
};

//----------------------------------------------------------------------

Component.prototype.setGameObject = function (gameObject){
	this.gameObject=gameObject;
};

//----------------------------------------------------------------------

Component.prototype.enable = function (){
	this.enabled=true;
};

//----------------------------------------------------------------------

Component.prototype.disable = function (){
	this.enabled=false;
};

//----------------------------------------------------------------------

Component.prototype.isEnabled = function (){
	return this.enabled;
};

//----------------------------------------------------------------------

Component.prototype.getParent = function(){
    var parent = this.gameObject.getParent();

    if(parent !== null)
        return parent.getComponent(this.constructor);

    return null;

};

//----------------------------------------------------------------------

Component.prototype.getChild = function (){
    return this.gameObject.getComponent(this.constructor);
};

//----------------------------------------------------------------------

Component.prototype.getChildren = function (){
    return this.gameObject.getComponentsInChildren(this.constructor);
};

//----------------------------------------------------------------------
var QuadTreeNode = function (leftTop, width, height, minWidth, minHeight, tree){
	this.LT = leftTop;
	this.width = width;
	this.height = height;
	this.minWidth = minWidth;
	this.minHeight = minHeight;
	this.tree = tree;

	// console.log("NEW NODE: LT:" + this.LT.x + "," + this.LT.y + " w:" + this.width + " h:" + this.height);

	this.colliders = [];
	this.children = new Array(4);

	this.children[0] = null;
	this.children[1] = null;
	this.children[2] = null;
	this.children[3] = null;

	// This array testPartialCollider the LeftTop Vertices of the 4 children.
	this.LTArray = new Array(4);
	this.LTArray[0] = new Vector2(this.LT.x, this.LT.y);
	this.LTArray[1] = new Vector2(this.LT.x, this.LT.y - this.height/2);
	this.LTArray[2] = new Vector2(this.LT.x + this.width/2, this.LT.y - this.height/2);
	this.LTArray[3] = new Vector2(this.LT.x + this.width/2, this.LT.y);

	this.enabledChildren = 0;
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.draw = function() {
	DebugRenderer.setTransformationMatrix(Matrix4.identity());

	DebugRenderer.drawLine(this.LT, this.LT.cpy().add(new Vector3(this.width,0,0)),Color.RED);
	DebugRenderer.drawLine(this.LT, this.LT.cpy().add(new Vector3(0,-this.height,0)),Color.RED);
	DebugRenderer.drawLine(this.LT.cpy().add(new Vector3(0,-this.height,0)), this.LT.cpy().add(new Vector3(this.width,-this.height,0)),Color.RED);
	DebugRenderer.drawLine(this.LT.cpy().add(new Vector3(this.width,-this.height,0)), this.LT.cpy().add(new Vector3(this.width,0,0)),Color.RED);

	DebugRenderer.setTransformationMatrix(null);
};

//----------------------------------------------------------------------


QuadTreeNode.prototype.isLeaf = function() {
	return this.enabledChildren === 0;
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.getCollidersCount = function() {
	return this.colliders.length;
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.testCompleteCollider = function (collider){

	var vertices = collider.getBoundingBox();

	var collision = true;

	for (var v = 0; (v < vertices.length); v++) {
		collision = collision && GeometryUtil.testRectanglePoint(this.LT,this.width,this.height,vertices[v]);
	}

	return collision;



};

//----------------------------------------------------------------------

QuadTreeNode.prototype.testPartialCollider = function (collider){

	var vertices = collider.getBoundingBox();

	var collision = false;

	for (var v = 0; (v < vertices.length) && ! collision; v++) {
		collision = collision  || GeometryUtil.testRectanglePoint(this.LT,this.width,this.height,vertices[v]);
	}

	return collision;
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.childNodeTestPartialCollider = function (i, collider){

	var vertices = collider.getBoundingBox();

	var collision = false;

	// For each collider vertex
	for (var v = 0; (v < vertices.length) && ! collision; v++) {
		collision = collision  || GeometryUtil.testRectanglePoint(this.LTArray[i],this.width/2,this.height/2,vertices[v]);
	}

	return collision;
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.createChildNode = function (i){
	this.enabledChildren++;
	return new QuadTreeNode(this.LTArray[i], this.width/2, this.height/2, this.minWidth, this.minHeight, this.tree);
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.isDivisible = function (){
 	return (this.width/2 >= this.minWidth) && (this.height/2 >= this.minHeight);
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.addCollider = function (collider){

	// If this node is divisible
	if(this.isDivisible()){
		//console.log("IS DIVISIBLE");

		// For each "posible" child node
		for (var i = 0; i < this.LTArray.length; i++){

			var isPartiallyInChildren = this.childNodeTestPartialCollider(i,collider);

			if( ( ! collider.isStatic()) || isPartiallyInChildren){

				if(isPartiallyInChildren){

					// If child doesn't exist, create it.
					if(this.children[i] === null)
						this.children[i] = this.createChildNode(i);

					this.children[i].addCollider(collider);
				}

			}
		}

	}else{

		if ( ( ! collider.isStatic()) || this.testPartialCollider(collider)) {

			var found = false;

			for (var i = 0; !found && i < this.colliders.length; i++) {
				found = (this.colliders[i].getId() == collider.getId());
			}

			if(!found){
				this.colliders.push(collider);
				// console.log("ADD COLLIDER " + collider.getId() +" TO -> " + this.LT.x + "," + this.LT.y + " w:" + this.width + " h:" + this.height);
			}
		}
	}
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.update = function (){

	// this.draw();

	var exitColliders = []; // colliders which have left the node.

	// If is leaf node.
	if(this.isLeaf()){

		// console.log(this.colliders.length);

		// FOR EACH COLLIDER
		for (var i = 0; i < this.colliders.length; i++){

			// if collider has left the node.
			if(this.checkExit(this.colliders[i]))
				exitColliders.push(this.colliders[i]);

			// if there are 2 or more colliders within the same node.
			if(this.colliders.length > 1){

				// CHECK COLLISIONS WITH THE OTHERS COLLIDERS
				for (var j= 0; j < this.colliders.length; j++){

					// ifthey aren't the same collider
					if(this.colliders[i].getId() !== this.colliders[j].getId()){

						// check bounding radius
						if(this.colliders[i].checkCollisionRadius(this.colliders[j])){

							// candidate vertices
							var vertices = this.colliders[i].getCandidateVertices(this.colliders[j]);

							// Compute candidates and generate contacts
							var contacts = [];
							var status = this.colliders[i].generateContacts(vertices, this.colliders[j], contacts);

							this.tree.addContacts(contacts);

							// console.log(this.tree.getStatus());
							if(this.tree.getStatus() != Collider.STATUS_PENETRATION && status!= Collider.STATUS_NONE)
								this.tree.setStatus(status);
						}
					}
				}
			}
		}


		this.manageExits(exitColliders);

	}else{
		this.updateChildren();
	}
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.updateChildren = function() {
	//console.log("CHECK");
	// for (var i = 0; i < this.children.length; i++)
	for (var i = 0; i < this.children.length; i++){

		var child = this.children[i];

		if(child !== null){

			if(child.isLeaf() && child.getCollidersCount() === 0){
				this.children[i] = null;
				this.enabledChildren--;
			}else{
				child.update();
			}
		}
	}
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.checkExit = function (collider){
	// CHECK if collider is out of this node.
	// only dynamic objects can escape from their nodes !!!
	return ( ! collider.isStatic() && ! this.testCompleteCollider(collider));
};

//----------------------------------------------------------------------

QuadTreeNode.prototype.manageExits = function (exitColliders){

	// If any collider has left the node
	if(exitColliders.length > 0){

		var remainingColliders = [];

		// for each collider
		for (var i = 0; i < this.colliders.length; i++) {

			var erased = false;

			// check if the collider has left the nodes
			for (var j = 0; j < exitColliders.length && !erased ; j++) {
				if(exitColliders[j].getId() === this.colliders[i].getId()){
					erased = true;
				}
			}

			if(!erased){
				remainingColliders.push(this.colliders[i]);
			}
		}

		this.colliders = remainingColliders;

		// RE-INSERT
		for (var i = 0; i < exitColliders.length; i++) {
			this.tree.addCollider(exitColliders[i]);
		}
	}
};

//----------------------------------------------------------------------
var QuadTree = function (width,height){
	this.width = width;
	this.height = height;
	this.root = new QuadTreeNode(new Vector2(-this.width/2,this.height/2), this.width, this.height, 2, 2, this);
	this.status = Collider.STATUS_NONE;
	this.contacts = [];
};

//----------------------------------------------------------------------

QuadTree.prototype.addCollider = function (collider){
	this.root.addCollider(collider);
};

//----------------------------------------------------------------------

QuadTree.prototype.clear = function (){
	this.root = new QuadTreeNode(new Vector2(-this.width/2,this.height/2), this.width, this.height, 2, 2, this);
};

//----------------------------------------------------------------------

QuadTree.prototype.getStatus = function (){
	return this.status;
};

//----------------------------------------------------------------------

QuadTree.prototype.setStatus = function (status){
	this.status = status;
};

//----------------------------------------------------------------------

QuadTree.prototype.getContacts = function (){
	return this.contacts;
};

//----------------------------------------------------------------------

QuadTree.prototype.addContacts = function (contactList){
	this.contacts = this.contacts.concat(contactList);
};

//----------------------------------------------------------------------

QuadTree.prototype.update = function (){
	this.status = Collider.STATUS_NONE;
	this.root.update();
};

//----------------------------------------------------------------------

QuadTree.prototype.clearContacts = function (){
	this.contacts = [];
	this.status = Collider.STATUS_NONE;
};

//----------------------------------------------------------------------
var PhysicsEngine = function (){
  this.bodies = [];

  // TODO refactor

  // var canvas = document.getElementById("glcanvas");
  // alert("Width: "+canvas.width/64 + " Height: " + canvas.height/64);
  // this.tree = new QuadTree(canvas.width/64,canvas.height/64);
  this.tree = new QuadTree(100,100);

};

//----------------------------------------------------------------------

PhysicsEngine.prototype.getBodies = function (){
  return this.bodies;
};

//----------------------------------------------------------------------

PhysicsEngine.prototype.addBodies = function (bodies){
  for (var i = 0; i < bodies.length; i++) {
    this.addBody(bodies[i]);
	}
};

//----------------------------------------------------------------------

PhysicsEngine.prototype.addBody = function (body){
  this.bodies.push(body);
  this.tree.addCollider(body.gameObject.getComponent(Collider));
};

//----------------------------------------------------------------------

PhysicsEngine.prototype.clear = function (){
	this.bodies = [];
  this.tree.clear();
};

//----------------------------------------------------------------------

PhysicsEngine.prototype.applyImpulse = function(bodyA, bodyB, vrel, normal){

  var invMass = 1/1;

  var vrn = vrel.dot(normal);



  // Do not resolve if bodies are separating
  if(vrn < 0){



    // Calculate restitution
    // var e = 2.5;
    var e = 0;

    // Calculate impulse scalar
    var j = -(1.0 + e) * vrn;
    j /= invMass + invMass;

    // Apply impulse
    var impulse = normal.cpy().mulScl(j);
    // console.log("impulse");
    // console.log(impulse);

    if( ! bodyA.isStatic()){
      bodyA.linear.add(impulse.cpy().mulScl(invMass));
      // console.log("A " + bodyA.getId());
      // console.log(bodyA.linear);
    }

    if( ! bodyB.isStatic()){
      bodyB.linear.sub(impulse.cpy().mulScl(invMass));
      // console.log("B " + bodyB.getId());
      // console.log(bodyB.linear);
    }


  }
};

//----------------------------------------------------------------------

PhysicsEngine.prototype.solveCollisions = function (contacts){

  var solved = {}; // colliders

  for (var i = 0; i < contacts.length; i++) {

    var normal = contacts[i].normal;
    var vrel = contacts[i].relativeVelocity;
    var a = contacts[i].colliderA;
    var b = contacts[i].colliderB;

    if(solved[a.getId()] === undefined){
      solved[a.getId()] = {};
      solved[a.getId()][b.getId()] = false;
    }

    if(solved[b.getId()] === undefined){
      solved[b.getId()] = {};
      solved[b.getId()][a.getId()] = false;
    }

    if( ! solved[a.getId()][b.getId()] && ! solved[b.getId()][a.getId()]){
      var bodyA = a.gameObject.getComponent(RigidBody);
      var bodyB = b.gameObject.getComponent(RigidBody);

      bodyA.setOnCollision(true);
      bodyB.setOnCollision(true);

      this.applyImpulse(bodyA,bodyB,vrel,normal);

      solved[a.getId()][b.getId()] = true;
      solved[b.getId()][a.getId()] = true;

    }
  }

  // console.log(solved);
};

//----------------------------------------------------------------------

PhysicsEngine.prototype.simulate = function (deltaTime){

  var currentTime = 0;
  // var deltaTime = Time.deltaTime();
  // var targetTime = Time.deltaTime();
  // var deltaTime = 1/30;
  var targetTime = deltaTime;
  var tol = 0.01;
  // var penetration = false;
  var tryAgain = true;

  // var dTime = Time.deltaTime();
  // var tol = 0.00001;

  for (var i = 0; i < this.bodies.length; i++) {
      this.bodies[i].saveState();
  }

  var it = 0;
  var maxIt = 10;
  var first = true;

  while ( tryAgain && (currentTime < deltaTime)) {
  // while ( tryAgain && deltaTime > tol) {

      tryAgain = false;

      // Integrate
      for (var i = 0; i < this.bodies.length; i++) {
        // Integrate the first time
        // OR
        // only re-integrate the penetration cases
        if(first || this.bodies[i].gameObject.getComponent(Collider).getStatus() === Collider.STATUS_PENETRATION){
          this.bodies[i].restoreState();
          this.bodies[i].simulate(targetTime - currentTime);
        }
    	}

      first = false;

      // check collisions
      this.tree.update();
      var status = this.tree.getStatus();

      if(status == Collider.STATUS_PENETRATION){

        // deltaTime -= deltaTime/2;
        //
        // console.log(deltaTime);

          if(it < maxIt)
            targetTime = (currentTime + targetTime)/2.0;
          else
            targetTime -= (deltaTime)/2.0; // HACK NEW

          tryAgain = true;

          // console.log("penetration");

      }else if (status == Collider.STATUS_COLLISION) {
          currentTime = targetTime;
          targetTime = deltaTime;

          // console.log("collision");

          this.solveCollisions(this.tree.getContacts());
      }

      this.tree.clearContacts();

      it++;
  }

  // console.log(it);
};

//----------------------------------------------------------------------

PhysicsEngine.prototype.update = function (){
  // var deltaTime = Time.deltaTime();

  var time = 1/30;
  var timeStep = (1/30)/5;
  var dt;
  var lastTime = 0;

  // Euler integration subdivision
  while (lastTime < time){

    dt = time - lastTime;

    if(dt > timeStep)
      dt = timeStep;

    this.simulate(dt);
    lastTime += dt;
  }
};

//----------------------------------------------------------------------
var State = function (body){
  this.position = body.gameObject.getTransform().position.cpy();
  this.rotation = body.gameObject.getTransform().rotation.cpy();
  this.static = body.static;
	this.linear = body.linear.cpy();
	this.angular = body.angular.cpy();
	this.mass = body.mass;
	this.onCollision = body.onCollision;
};

//----------------------------------------------------------------------

State.prototype.restore = function (body) {
  body.gameObject.getTransform().setPosition(this.position.cpy());
  body.gameObject.getTransform().setRotation(this.rotation.cpy());
  body.static = this.static;
	body.linear = this.linear.cpy();
	body.angular = this.angular.cpy();
	body.mass = this.mass;
	body.onCollision = this.onCollision;
};

//----------------------------------------------------------------------
var RigidBody = function (){
	Component.call(this);
	this.linear = new Vector3(0,0,0);
	this.angular = new Vector3(0,0,0);
	this.mass = 0;
	this.onCollision = false;
	this.savedState = null;
};

RigidBody.prototype = new Component();
RigidBody.prototype.constructor = RigidBody;

//----------------------------------------------------------------------

RigidBody.prototype.getCollider = function () {
	return this.gameObject.getComponent(Collider);
};

//----------------------------------------------------------------------

RigidBody.prototype.isStatic = function () {
	return this.gameObject.isStatic();
};

//----------------------------------------------------------------------

RigidBody.prototype.setOnCollision = function (bool) {
	this.onCollision = bool;
};

//----------------------------------------------------------------------

RigidBody.prototype.isOnCollision = function () {
	return this.onCollision;
};

//----------------------------------------------------------------------

RigidBody.prototype.saveState = function () {
	this.savedState = new State(this);
};

//----------------------------------------------------------------------

RigidBody.prototype.restoreState = function () {
	if(this.savedState !== null)
		this.savedState.restore(this);
};

//----------------------------------------------------------------------

RigidBody.prototype.simulate = function (time) {
	var t = this.gameObject.getTransform();
	t.translate(this.linear.cpy().mulScl(time));
};

//----------------------------------------------------------------------
// Class definition goes here.
var Contact = function (colliderA, colliderB, contactPoint, normal, relativeVelocity){
  this.colliderA = colliderA; // Collider A
  this.colliderB = colliderB; // Collider B
  this.contactPoint = contactPoint;
  this.normal = normal; // From B to A
  this.relativeVelocity = relativeVelocity;
};

//----------------------------------------------------------------------
var Collider = function () {
	Component.call(this);
	this.status = 0;
};

Collider.STATUS_NONE = 0;
Collider.STATUS_PENETRATION = 1;
Collider.STATUS_COLLISION = 2;

Collider.depthEpsilon = 0.02;

Collider.prototype = new Component();
Collider.prototype.constructor = Collider;

//----------------------------------------------------------------------

Collider.prototype.isStatic = function () {
	return this.gameObject.isStatic();
};

//----------------------------------------------------------------------

Collider.prototype.getStatus = function () {
	return this.status;
};

//----------------------------------------------------------------------

Collider.prototype.setStatus = function (status) {
	this.status = status;
};

//----------------------------------------------------------------------

Collider.prototype.getVertices = function () {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.getFaces = function () {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.getEdges = function () {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.getBoundingBox = function () {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.getRadius = function () {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.getCenter = function () {
	return this.gameObject.getTransform().position;
};

//----------------------------------------------------------------------

Collider.prototype.getNormals = function() {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.getRelativeVelocity = function(otherCollider) {

	var velA = this.gameObject.getComponent(RigidBody).linear;
	var velB = otherCollider.gameObject.getComponent(RigidBody).linear;

	return velA.cpy().sub(velB);
};

//----------------------------------------------------------------------


Collider.prototype.testPoint = function (vec) {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.getCandidateVertices = function (otherCollider) {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.checkCollisionRadius = function (otherCollider) {
	var centerA = this.gameObject.getTransform().position;
	var centerB = otherCollider.gameObject.getTransform().position;

	return GeometryUtil.testSphereSphere(centerA,centerB,this.getRadius(),otherCollider.getRadius());
};

//----------------------------------------------------------------------

Collider.prototype.testVertexVertex = function (vertices, otherCollider, contactList) {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.testVertexEdge = function (vertices, otherCollider, contactList) {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Collider.prototype.checkCollisionOrPenetration = function (vertex, maxDistance, normal, otherCollider, contactList) {

	var result = Collider.STATUS_NONE;

	var eps = Collider.depthEpsilon;

	var vrel = this.getRelativeVelocity(otherCollider);

	var vrn = vrel.dot(normal);

	if(vrn < 0.0){
		if(maxDistance < -eps){ // penetration
			// if(vrn < 0.0){
				// console.log("VERTEX-VERTEX PENETRATION " + maxDistance);
				// hasInterpenetration = true;

				result = Collider.STATUS_PENETRATION;

				this.setStatus(Collider.STATUS_PENETRATION);
				otherCollider.setStatus(Collider.STATUS_PENETRATION);
			// }

		}else if(maxDistance < eps){ // collision

			// if(vrn < 0.0){

				// counter++;
				//
				// if(counter < 2){

				// console.log("VERTEX-VERTEX COLLISION ");
				contactList.push(new Contact(this, otherCollider, vertex, normal, vrel));
				result = Collider.STATUS_COLLISION;
				this.setStatus(Collider.STATUS_COLLISION);
				otherCollider.setStatus(Collider.STATUS_COLLISION);
				// hasInterpenetration = true;
				// }else{
				// 	hasInterpenetration = false;
				// }
			// }
		}
	}

	return result;

};

//----------------------------------------------------------------------

Collider.prototype.generateContacts = function (vertices, otherCollider, contactList) {
	throw new Error("Abstract method!");
};

//----------------------------------------------------------------------
var Collider2D = function (width,height) {
	Collider.call(this);

	this.width = width;
  this.height = height;
  this.LT = null;
  this.LB = null;
  this.RB = null;
  this.RT = null;
};

Collider2D.prototype = new Collider();
Collider2D.prototype.constructor = Collider2D;

//----------------------------------------------------------------------

Collider2D.prototype.getBoundingBox = function () {
	var t = this.gameObject.getTransform();

  if(t.isDirty()){
    var center = this.getCenter();

  	this.LT = new Vector3(center.x-(this.width/2),center.y+(this.height/2), center.z); // LEFT TOP VERTEX
  	this.LB = new Vector3(this.LT.x, this.LT.y - this.height, center.z); // LEFT BOTTOM
  	this.RB = new Vector3(this.LT.x + this.width, this.LT.y - this.height, center.z); // RIGHT BOTTOM
  	this.RT = new Vector3(this.LT.x + this.width, this.LT.y, center.z); // RIGHT TOP
  }

  return [this.LT, this.LB, this.RB, this.RT];
};

//----------------------------------------------------------------------

Collider2D.prototype.generateContacts = function (vertices, otherCollider, contactList) {


	var resultVertexVertex = this.testVertexVertex(vertices, otherCollider, contactList);

	var resultVertexEdge = Collider.STATUS_NONE;

	// if penetration/collision has been detected in vertex-vertex phase, we don't need to check vertex-edge.
	// if(resultVertexVertex !== Collider.STATUS_PENETRATION){
	if(resultVertexVertex === Collider.STATUS_NONE){
		resultVertexEdge = this.testVertexEdge(vertices, otherCollider, contactList);
	}

	// if one test has detected something.
	if(resultVertexVertex !== Collider.STATUS_NONE || resultVertexEdge !== Collider.STATUS_NONE){

	  var hasInterpenetration = resultVertexVertex === Collider.STATUS_PENETRATION || resultVertexEdge === Collider.STATUS_PENETRATION;
		var hasCollision = resultVertexVertex === Collider.STATUS_COLLISION || resultVertexEdge === Collider.STATUS_COLLISION;

		if(hasInterpenetration){
			// console.log("PENETRATION");
			return Collider.STATUS_PENETRATION;
		}else if(hasCollision){
			// console.log("COLLISION");
			return Collider.STATUS_COLLISION;
		}
	}


	// console.log("none");
  return Collider.STATUS_NONE;
};

//----------------------------------------------------------------------
var Polygon = function (width, height) {
  Collider2D.call(this, width, height);
};

Polygon.prototype = new Collider2D();
Polygon.prototype.constructor = Polygon;

//----------------------------------------------------------------------

Polygon.prototype.testVertexVertex = function (vertices, otherCollider, contactList) {

  var result = Collider.STATUS_NONE;

  var eps = Collider.depthEpsilon; // Error

	var otherVertices = otherCollider.getVertices();

	// VERTEX - VERTEX

	var foundVertexVertex = false; // true if d< eps
	// var counter = 0;
	// var double = new Array(2);

	var center = this.getCenter().cpy();

  // for all vertices
  for (var i = 0; i < vertices.length && !foundVertexVertex; i++) {

		// foundVertexVertex = false;

		var vertex = vertices[i];

    // flag interior vertex -> 1 , -1
    var interior = otherCollider.testPoint(vertex) ? -1 : 1;

    var maxDistance = -Infinity; // distance
    var normal = null; // the collision normal

		// vertex - vertex
	  for (var j = 0; j < otherVertices.length && !foundVertexVertex; j++) {

			var otherVertex = otherVertices[j];

	    // var d= vertex.dst(otherVertex);
	    var d = vertex.dst(otherVertex);
			d *= interior;

			// if "collision"
			// if(Math.abs(d) <= Math.abs(eps)){
          if(d <= eps){

						foundVertexVertex = true;

            // max
            if(d > maxDistance){

                maxDistance = d;
								normal = center.sub(otherCollider.getCenter()).nor();

            }
          }
			// }
    }

		if(foundVertexVertex){
      result = this.checkCollisionOrPenetration(vertex, maxDistance, normal, otherCollider, contactList);
    }

	}

  return result;
};

//----------------------------------------------------------------------

Polygon.prototype.testVertexEdge = function (vertices, otherCollider, contactList) {

  var result = Collider.STATUS_NONE;

  var eps = Collider.depthEpsilon; // Error

  var edges = otherCollider.getEdges(); // otherCollider's edges
  var normals = otherCollider.getNormals(); // the normals of this collider


  for (var i = 0; i < vertices.length && result !== Collider.STATUS_PENETRATION; i++) {

    var vertex = vertices[i];

    var normal = null; // the collision normal

    // var distanceToSegment= -Infinity; // distance
    var foundVertexEdge = false; // true if d< eps
    var maxDistance = -Infinity;

    // flag interior vertex -> 1 , -1
    var interior = otherCollider.testPoint(vertex) ? -1 : 1;



    if(otherCollider instanceof CircleCollider){

      var closest = GeometryUtil.closestPointInSphere(vertex,otherCollider.getCenter(),otherCollider.getRadius());

      var d = vertex.dst(closest);
      d *= interior; // negative if interior

      // console.log(d);

      if( d < eps){
        foundVertexEdge = true;
      }

      maxDistance = d;
      normal = closest.cpy().sub(vertex).nor();

    }else if(otherCollider instanceof Polygon){

      // vertex - edge
      for (var j = 0; j < edges.length && result !== Collider.STATUS_PENETRATION; j++) {

        var a = edges[j][0];
        var b = edges[j][1];

        var d = GeometryUtil.distanceToSegment(vertex,a,b);

        d *= interior; // negative if interior

        // if "collision"
        if( d < eps){

          foundVertexEdge = true;

          if(d > maxDistance){
            maxDistance = d;
            normal = normals[j];

          }
        }
      }
    }

    if(foundVertexEdge){
      result = this.checkCollisionOrPenetration(vertex, maxDistance, normal, otherCollider, contactList);
    }
  }

  return result;
};

//----------------------------------------------------------------------
var AABBCollider = function (width, height) {
  Polygon.call(this, width, height);
};

AABBCollider.prototype = new Polygon();
AABBCollider.prototype.constructor = AABBCollider;

//----------------------------------------------------------------------

AABBCollider.prototype.getVertices = function () {
  return this.getBoundingBox();
};

//----------------------------------------------------------------------

AABBCollider.prototype.getEdges = function () {

  var vertices = this.getVertices();
  var edges = [];

  for (var i = 0; i < vertices.length; i++) {
  	a = vertices[i];
  	b = vertices[(i+1)%4];

    edges.push([a,b]);
  }

  return edges;
};

//----------------------------------------------------------------------

AABBCollider.prototype.getRadius = function () {
	// diagonal
  return Math.sqrt(( this.width * this.width ) + (  this.height * this.height )) / 2.0;
};

//----------------------------------------------------------------------

AABBCollider.prototype.getNormals = function () {
  var normals = [];
  var center = this.getCenter();

  var p = new Vector2(center.x-1, center.y);
  normals[0] = p.sub(center);

  p = new Vector2(center.x, center.y-1);
  normals[1] = p.sub(center);

  p = new Vector2(center.x+1, center.y);
  normals[2] = p.sub(center);

  p = new Vector2(center.x, center.y+1);
  normals[3] = p.sub(center);

  return normals;
};

//----------------------------------------------------------------------

AABBCollider.prototype.testPoint = function (vec) {

  if(this.LT === null){
    var center = this.getCenter();
  	this.LT = new Vector3(center.x-(this.width/2),center.y+(this.height/2), center.z);
  }

	return GeometryUtil.testRectanglePoint(this.LT, this.width, this.height, vec);
};

//----------------------------------------------------------------------

AABBCollider.prototype.getCandidateVertices = function (otherCollider, contactList) {
  return this.getVertices();
};

//----------------------------------------------------------------------
var CircleCollider = function (radius) {
    Collider2D.call(this, radius*2, radius*2);
    this.radius = radius;
};

CircleCollider.prototype = new Collider2D();
CircleCollider.prototype.constructor = CircleCollider;


//----------------------------------------------------------------------

CircleCollider.prototype.getVertices = function () {
  return [];
};

//----------------------------------------------------------------------

CircleCollider.prototype.getEdges = function () {
  return [];
};

//----------------------------------------------------------------------

CircleCollider.prototype.getRadius = function () {
  return this.radius;
};

//----------------------------------------------------------------------

CircleCollider.prototype.getNormals = function() {
  return [];
};

//----------------------------------------------------------------------

CircleCollider.prototype.testPoint = function (vec) {
  var distance = vec.dst(this.getCenter());
	return (distance <= this.radius);
};

//----------------------------------------------------------------------

CircleCollider.prototype.getCandidateVertices = function (otherCollider) {

  var candidates = [];

  var center = this.getCenter();

  if(otherCollider instanceof CircleCollider){

    var otherCenterToCenter = otherCollider.getCenter().cpy().sub(this.getCenter());

    var radiusVector = otherCenterToCenter.cpy().nor().mulScl(this.getRadius());

    // var closestPointInSphere = vertexToCenter.cpy().sub(radiusVector);

    var closestPointInSphere = this.getCenter().cpy().add(radiusVector);

    // closest point in circle to the other circle
    candidates.push(closestPointInSphere);


  }else if(otherCollider instanceof Polygon){

    var edges =  otherCollider.getEdges();

    var minDistance = Infinity;
    var closest = null;

    for (var i = 0; i < edges.length; i++){

      var a = edges[i][0];
      var b = edges[i][1];

      var p = GeometryUtil.closestPointInSegment(center,a,b);
      var d = center.dst(p);

      if(d < minDistance){
        minDistance = d;
        closest = p;
      }
    }

    var closestPointInSphere = GeometryUtil.closestPointInSphere(closest,center,this.getRadius());

    // closest point in circle to the edge
    candidates.push(closestPointInSphere);
  }



  return candidates; // here there is only one vertex.
};

//----------------------------------------------------------------------

CircleCollider.prototype.testVertexVertex = function (vertices, otherCollider, contactList) {

  var result = Collider.STATUS_NONE;

  var eps = Collider.depthEpsilon; // Error

  for (var i = 0; i < vertices.length && result !== Collider.STATUS_PENETRATION; i++) {

    var vertex = vertices[i];

    var normal = null; // the collision normal

    // var distanceToSegment= -Infinity; // distance
    var foundVertexEdge = false; // true if d< eps
    var maxDistance = -Infinity;

    // flag interior vertex -> 1 , -1
    var interior = otherCollider.testPoint(vertex) ? -1 : 1;


    if(otherCollider instanceof CircleCollider){

      var closest = GeometryUtil.closestPointInSphere(vertex,otherCollider.getCenter(),otherCollider.getRadius());

      var d = vertex.dst(closest);
      d *= interior; // negative if interior

      // console.log(d);

      if( d < eps){
        foundVertexEdge = true;
      }

      maxDistance = d;
      normal = closest.cpy().sub(vertex).nor();

    }else if(otherCollider instanceof AABBCollider){

      var edges = otherCollider.getEdges(); // otherCollider's edges
      var normals = otherCollider.getNormals(); // the normals of this collider

      // vertex - edge
      for (var j = 0; j < edges.length && result !== Collider.STATUS_PENETRATION; j++) {

        var a = edges[j][0];
        var b = edges[j][1];

        var d = GeometryUtil.distanceToSegment(vertex,a,b);

        d *= interior; // negative if interior

        // if "collision"
        if( d < eps){

          foundVertexEdge = true;

          if(d > maxDistance){
            maxDistance = d;
            normal = normals[j];

          }
        }
      }


    }

    if(foundVertexEdge){
      result = this.checkCollisionOrPenetration(vertex, maxDistance, normal, otherCollider, contactList);
    }


  }

  return result;
};

//----------------------------------------------------------------------

CircleCollider.prototype.testVertexEdge = function (vertices, otherCollider, contactList) {
  return Collider.STATUS_NONE;
};

//----------------------------------------------------------------------
var Scene = function (name){

  this.name = name;

  this.root = new GameObject();
  this.camera = null;
  this.renderContext = null;

  this.newsRoot = new GameObject(); // Root Node where the new objects are stored.

  this.newObjects = false;
  this.loaded = false;

  this.trash = [];

};


//----------------------------------------------------------------------

Scene.prototype.getName = function (){
	return this.name;
};

//----------------------------------------------------------------------

Scene.prototype.setLoaded = function (bool){
	this.loaded=bool;
};

//----------------------------------------------------------------------

Scene.prototype.isLoaded = function (){
	return this.loaded;
};

//----------------------------------------------------------------------

Scene.prototype.getRoot = function (){
  return this.root;
};

//----------------------------------------------------------------------

Scene.prototype.getNewsRoot = function (){
	return this.newsRoot;
};

//----------------------------------------------------------------------

Scene.prototype.flush = function (){
  this.root.setChildren(this.root.getChildren().concat(this.newsRoot.getChildren()));
  this.newsRoot.setChildren([]);
  this.newObjects = false;
};

//----------------------------------------------------------------------

Scene.prototype.hasNewObjects = function (){
	return this.newObjects;
};

//----------------------------------------------------------------------

Scene.prototype.addObject = function (obj){
  // console.log("ADD OBJECT: " + obj.getId());
  this.newObjects = true;

  obj.setScene(this);
  obj.getTransform().initMatrix();
  this.newsRoot.addChild(obj);
};

//----------------------------------------------------------------------

Scene.prototype.deleteObject = function (obj){
  this.trash.push(obj);
};

//----------------------------------------------------------------------

Scene.prototype.cleanTrash = function (obj){

  for (var i = 0; i < this.trash.length; i++) {
    // TODO remove deleted objects
  }

  this.trash = [];
};

//----------------------------------------------------------------------

Scene.prototype.getRenderContext = function (){
	return this.renderContext;
};

//----------------------------------------------------------------------

Scene.prototype.setRenderContext = function (renderContext){
	this.renderContext=renderContext;
};

//----------------------------------------------------------------------

Scene.prototype.getCamera = function (){
	return this.camera;
};

//----------------------------------------------------------------------

Scene.prototype.setCamera = function (camera){
	this.camera=camera;
};

//----------------------------------------------------------------------
var Transform = function (){
	Component.call(this);
	this.position = new Vector3(0,0,0);
	this.rotation = new Vector3(0,0,0);
	this.scale = new Vector3(1,1,1);

	this.right = new Vector3(1,0,0);
	this.up = new Vector3(0,1,0);
	this.forward = new Vector3(0,0,1);

  this.matrix = Matrix4.identity();
  // this.parentMatrix = Matrix4.identity();
	// this.matrixStaticGenerated = false;

	this.target = this.forward.cpy();

	this.dirty = true;
};

Transform.prototype = new Component();
Transform.prototype.constructor = Transform;

//----------------------------------------------------------------------

Transform.prototype.isStatic = function () {
	return this.gameObject.isStatic();
};

//----------------------------------------------------------------------

Transform.prototype.isDirty = function () {
	return this.dirty;
};

//----------------------------------------------------------------------

// Transform.prototype.setParentMatrix = function (parentMatrix) {
// 	this.parentMatrix = parentMatrix;
// };

Transform.prototype.generateLocalSpaceMatrix = function (){
	this.matrix = Matrix4.scale(this.scale);
	this.matrix = Matrix4.mulMM(this.matrix, Matrix4.rotation(new Vector3(this.rotation.x, 0, 0)));
	this.matrix = Matrix4.mulMM(this.matrix, Matrix4.rotation(new Vector3(0, this.rotation.y, 0)));
	this.matrix = Matrix4.mulMM(this.matrix, Matrix4.rotation(new Vector3(0, 0, this.rotation.z)));
	this.matrix = Matrix4.mulMM(this.matrix, Matrix4.translation(this.position));

};

//----------------------------------------------------------------------

Transform.prototype.initMatrix = function (){

	this.generateLocalSpaceMatrix();

	var parent = this.getParent();

	if(parent !== null)
		this.matrix = Matrix4.mulMM(this.matrix,parent.getMatrix());

	var children = this.getChildren();

	for (c of children){
		c.initMatrix();
	}
};


//----------------------------------------------------------------------

Transform.prototype.getMatrix = function (){
	return this.matrix;
};

//----------------------------------------------------------------------

Transform.prototype.generateMatrix = function (){

	// If this transform is not static
	if(! this.isStatic()){

		var parent = this.getParent();

		// If this transform has parent -> generate local + parent matrix
		if(parent !== null && parent.isDirty()){
			this.generateLocalSpaceMatrix();
			this.matrix = Matrix4.mulMM(this.matrix,parent.getMatrix());

		// Else, generate only local matrix
		}else if(this.dirty)
			this.generateLocalSpaceMatrix();

	}

	// update children
	for (c of this.getChildren()){
		c.generateMatrix();
	}

	this.dirty = false; // clear dirty flag

	// DebugRenderer.setTransformationMatrix(this.matrix);
    // DebugRenderer.drawLine(this.position,this.position.cpy().add(this.right).mulScl(-20),Color.GREEN);
    // DebugRenderer.drawLine(new Vector3(0,0,0),new Vector3(0,0.5,0),Color.BLUE);
    // DebugRenderer.drawLine(new Vector3(0,0,0),new Vector3(0,0,0.5),Color.RED);
	// DebugRenderer.setTransformationMatrix(null);


};


//----------------------------------------------------------------------

Transform.prototype.setMatrix = function(matrix){
	this.matrix = matrix;

	this.dirty = true;
};

//----------------------------------------------------------------------

Transform.prototype.setPosition = function (vec){

	if( ! this.position.equals(vec)){
		this.dirty = true;

		// this.position.x = vec.x;
		// this.position.y = vec.y;
		// this.position.z = vec.z;

		this.position.set(vec);
	}
};

//----------------------------------------------------------------------

Transform.prototype.setRotation = function (vec){

	if( ! this.rotation.equals(vec)){
		this.dirty = true;

		// this.rotation.x = vec.x;
		// this.rotation.y = vec.y;
		// this.rotation.z = vec.z;

		this.rotation.set(vec);
	}
};

//----------------------------------------------------------------------

Transform.prototype.setScale = function (vec){

	if( ! this.scale.equals(vec)){
		this.dirty = true;

		// this.scale.x = vec.x;
		// this.scale.y = vec.y;
		// this.scale.z = vec.z;

		this.scale.set(vec);
	}
};

//----------------------------------------------------------------------

Transform.prototype.getPosition = function (){
	return this.position;
};

//----------------------------------------------------------------------

Transform.prototype.getRotation = function (){
	return this.rotation;
};

//----------------------------------------------------------------------

Transform.prototype.getScale = function (){
	return this.scale;
};

//----------------------------------------------------------------------


Transform.prototype.translate = function (vec){

	if(vec.len() > 0){
		// this.position.x = vec.x + this.position.x;
		// this.position.y = vec.y + this.position.y;
		// this.position.z = vec.z + this.position.z;

		this.position.add(vec);

		this.dirty = true;
	}
};

//----------------------------------------------------------------------

Transform.prototype.rotate = function (vec){

	if(vec.len() > 0){
		// this.rotation.x = vec.x + this.rotation.x;
		// this.rotation.y = vec.y + this.rotation.y;
		// this.rotation.z = vec.z + this.rotation.z;

		this.rotation.add(vec);

		this.dirty = true;
	}
};

//----------------------------------------------------------------------

Transform.prototype.setScale = function (vec){

	if(vec.len() > 0){
		// this.scale.x = vec.x; //+ this.scale.x;
		// this.scale.y = vec.y; //+ this.scale.y;
		// this.scale.z = vec.z; //+ this.scale.z;

		this.scale.set(vec);

		this.dirty = true;
	}
};

//----------------------------------------------------------------------

Transform.prototype.lookAt = function (vec){

	if( ! this.target.equals(vec)){
		this.dirty = true;

		this.target = vec.cpy();

		var pos = this.position.cpy();

		this.forward = pos.sub(vec).nor();

		var yAxis = new Vector3(0,1,0);
		this.right = yAxis.cross(this.forward).nor();
		this.up = this.forward.cpy().cross(this.right);

	}


};

//----------------------------------------------------------------------
var MeshRenderer = function (){
	Component.call(this);
	this.mesh = null;
	this.material = null;

	// texture region
  this.regionPosition = new Vector2(0.0,0.0);
  this.regionWidth = 1.0;
  this.regionHeight = 1.0;

  // alpha color
  this.alphaColor = new Color(-1,-1,-1,-1);
};

MeshRenderer.prototype = new Component();
MeshRenderer.prototype.constructor = MeshRenderer;

//----------------------------------------------------------------------

MeshRenderer.prototype.getMesh = function (){
	return this.mesh;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.setMesh = function (mesh){
	this.mesh=mesh;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.getMaterial = function (){
	return this.material;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.setMaterial = function (material){
	this.material=material;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.getRadius = function () {

	var t = this.gameObject.getTransform();
	var scale = t.getScale();

	var max = this.mesh.getMax();

	var width = max.x * scale.x;
	var height = max.y * scale.y;
	var depth = max.z * scale.z;

	return Math.sqrt(( width * width ) + (  height * height ) + (  depth * depth )) / 2.0;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.getAlphaColor = function (){
	return this.alphaColor;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.setAlphaColor = function (color){
	this.alphaColor = color;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.setRegion = function (pos, width, height){
  this.regionPosition = pos;
  this.regionWidth = width;
  this.regionHeight = height;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.getRegionPosition = function (){
	return this.regionPosition;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.getRegionWidth = function (){
	return this.regionWidth;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.getRegionHeight = function (){
	return this.regionHeight;
};

//----------------------------------------------------------------------

MeshRenderer.prototype.updateMaterial = function (material){
  if(material.getTexture() !== null){


    var shader = material.getShader();

    shader.addFloatVector(this.alphaColor.toArray(),"alphacolor");

    shader.addFloat(this.getRegionPosition().x, "regionX");
    shader.addFloat(this.getRegionPosition().y, "regionY");
    shader.addFloat(this.getRegionWidth(), "regionWidth");
    shader.addFloat(this.getRegionHeight(), "regionHeight");

    if(this.animation !== null){
      var frame = this.animation.getNextFrame();

      shader.addFloat(frame.getPosition().x, "animationX");
    	shader.addFloat(frame.getPosition().y, "animationY");
    	shader.addFloat(frame.getWidth(), "animationWidth");
    	shader.addFloat(frame.getHeight(), "animationHeight");
    }


  }
};

//----------------------------------------------------------------------
var LineRenderer = function (shader,start,end,color, transformationMatrix){
    this.shader = shader;
    this.color = color;

    this.transformationMatrix = transformationMatrix;

    this.start = start.cpy();
    this.end = end.cpy();

    this.start.w = 1;
    this.end.w = 1;

    this.vertices = this.start.toArray().concat(this.end.toArray());

    this.colors = this.color.vec.toArray().concat(this.color.vec.toArray());

    this.elem = [];
    this.elem[0] = 0;
    this.elem[1] = 1;


    this.vboPosition = 0;
  	this.vboColor = 0;
  	this.vboElemIndices = 0;

  	this.vao = 0;
};

//----------------------------------------------------------------------

LineRenderer.prototype.bind = function () {

    this.vao = vao_ext.createVertexArrayOES();

    vao_ext.bindVertexArrayOES(this.vao);

    gl.enableVertexAttribArray(0);

  	// Create some buffers
  	this.vboPosition = gl.createBuffer();
  	gl.bindBuffer(gl.ARRAY_BUFFER, this.vboPosition);
  	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.vertices), gl.STATIC_DRAW); // TODO DYNAMIC
  	gl.vertexAttribPointer(0, 4, gl.FLOAT, false, 0, 0);

  	gl.enableVertexAttribArray(1);

    this.vboColor = gl.createBuffer();
  	gl.bindBuffer(gl.ARRAY_BUFFER, this.vboColor);

  	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(this.colors), gl.STATIC_DRAW); // TODO DYNAMIC
  	gl.vertexAttribPointer(1, 4, gl.FLOAT, false, 0, 0);


      this.vboElemIndices = gl.createBuffer();

  	gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.vboElemIndices);
  	gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(this.elem), gl.STATIC_DRAW);

    vao_ext.bindVertexArrayOES(null);
};

//----------------------------------------------------------------------


LineRenderer.prototype.render = function () {
    this.shader.enable();

    this.shader.addMatrix(this.transformationMatrix.transpose(), "transformationMatrix");

  	vao_ext.bindVertexArrayOES(this.vao);

  	gl.enableVertexAttribArray(0);
  	gl.enableVertexAttribArray(1);

  	gl.drawElements(gl.LINES, 2, gl.UNSIGNED_SHORT, 0);

      this.shader.disable();

  	gl.disableVertexAttribArray(0);
  	gl.disableVertexAttribArray(1);

};

//----------------------------------------------------------------------
var SpriteRenderer = function (){
  MeshRenderer.call(this);

  this.setMesh(new RectangleMesh());

  // Animations
  this.animations = [];
  this.animation = null;

};

SpriteRenderer.prototype = new MeshRenderer();
SpriteRenderer.prototype.constructor = SpriteRenderer;

//----------------------------------------------------------------------

SpriteRenderer.prototype.setAnimation = function (name){
	this.animation = this.animations[name];
};

//----------------------------------------------------------------------

SpriteRenderer.prototype.addAnimation = function (name, animation){
	this.animations[name] = animation;
};

//----------------------------------------------------------------------
var Frustum = function (camera){
	this.camera = camera;
	this.planes = new Array(6);

  for (var i = 0; i < this.planes.length; i++) {
      this.planes[i] = new Vector3(0,0,0); // x,y,z,w <=> A,B,C,D
  }

	this.VPmatrix = Matrix4.identity();
};

//----------------------------------------------------------------------

Frustum.prototype.testSphere = function (center, radius){
	// console.log("TEST SPHERE");
	for (var i = 0; i < this.planes.length; i++) {

		var A = this.planes[i].x;
		var B = this.planes[i].y;
		var C = this.planes[i].z;
		var D = this.planes[i].w;

		// console.log(A+" "+B+" "+C+" "+D);
		// console.log(-radius);
		// console.log((A*center.x)+(B*center.y)+(C*center.z)+D);

		if((A*center.x)+(B*center.y)+(C*center.z)+D <= -radius)
			return false;
	}

	return true;
};

//----------------------------------------------------------------------

Frustum.prototype.build = function (){

	var t = this.camera.getGameObject().getTransform();

	if(t.isDirty()){

	  var LEFT = 0;
	  var RIGHT = 1;
	  var BOTTOM = 2;
	  var TOP = 3;
	  var NEAR = 4;
	  var FAR = 5;

		// var camPos = t.position;

	  // var this.VPmatrix = Matrix4.mulMM(this.camera.getProjectionMatrix(),this.camera.getViewMatrix());
	  this.VPmatrix = Matrix4.mulMM(this.camera.getViewMatrix(),this.camera.getProjectionMatrix());
		this.VPmatrix = this.VPmatrix.transpose();

		// this.VPmatrix = Matrix4.mulMM(Matrix4.translation(new Vector3(-3,0,0)),this.VPmatrix)

		var d = new Array(6);

		/*
		* LEFT
		*/
	  this.planes[LEFT].x = this.VPmatrix.get(0,0) + this.VPmatrix.get(0,3);
	  this.planes[LEFT].y = this.VPmatrix.get(1,0) + this.VPmatrix.get(1,3);
	  this.planes[LEFT].z = this.VPmatrix.get(2,0) + this.VPmatrix.get(2,3);
	  // this.planes[LEFT].w = this.VPmatrix.get(3,0) + this.VPmatrix.get(3,3);

		// this.planes[LEFT] = this.planes[LEFT].nor();

		d[LEFT] =  this.VPmatrix.get(3,0) + this.VPmatrix.get(3,3) //+  ;;
		//
		// if(this.planes[LEFT].len() > 0)
		// 	d[LEFT] = d[LEFT]/this.planes[LEFT].len();
		//
		// this.planes[LEFT].w = d[LEFT] //+ camPos.x ;
		//
		// console.log("LEFT"+"\t"+this.planes[LEFT].x.toFixed(3) +" "+ this.planes[LEFT].y.toFixed(3) +" "+ this.planes[LEFT].z.toFixed(3) +" "+ this.planes[LEFT].w.toFixed(3));

		/*
		* RIGHT
		*/
	  this.planes[RIGHT].x = -this.VPmatrix.get(0,0) + this.VPmatrix.get(0,3);
	  this.planes[RIGHT].y = -this.VPmatrix.get(1,0) + this.VPmatrix.get(1,3);
	  this.planes[RIGHT].z = -this.VPmatrix.get(2,0) + this.VPmatrix.get(2,3);
	  // this.planes[RIGHT].w = -this.VPmatrix.get(3,0) + this.VPmatrix.get(3,3);

		// this.planes[RIGHT] = this.planes[RIGHT].nor();

		d[RIGHT] =  -this.VPmatrix.get(3,0) + this.VPmatrix.get(3,3) //+  ;
		//
		// if(this.planes[RIGHT].len() > 0)
		// 	d[RIGHT] = d[RIGHT]/this.planes[RIGHT].len();
		//
		// this.planes[RIGHT].w = d[RIGHT] //+ camPos.x ;
		//
		// console.log("RIGHT"+"\t"+this.planes[RIGHT].x.toFixed(3) +" "+ this.planes[RIGHT].y.toFixed(3) +" "+ this.planes[RIGHT].z.toFixed(3) +" "+ this.planes[RIGHT].w.toFixed(3));

		/*
		* BOTTOM
		*/
	  this.planes[BOTTOM].x = this.VPmatrix.get(0,1) + this.VPmatrix.get(0,3);
	  this.planes[BOTTOM].y = this.VPmatrix.get(1,1) + this.VPmatrix.get(1,3);
	  this.planes[BOTTOM].z = this.VPmatrix.get(2,1) + this.VPmatrix.get(2,3);
	  // this.planes[BOTTOM].w = this.VPmatrix.get(3,1) + this.VPmatrix.get(3,3);

		// this.planes[BOTTOM] = this.planes[BOTTOM].nor();

		d[BOTTOM] =  this.VPmatrix.get(3,1) + this.VPmatrix.get(3,3) //+  ;;
		//
		// if(this.planes[BOTTOM].len() > 0)
		// 	d[BOTTOM] = d[BOTTOM]/this.planes[BOTTOM].len();
		//
		// this.planes[BOTTOM].w = d[BOTTOM] //+ camPos.y ;
		//
		// console.log("BOTTOM"+"\t"+this.planes[BOTTOM].x.toFixed(3) +" "+ this.planes[BOTTOM].y.toFixed(3) +" "+ this.planes[BOTTOM].z.toFixed(3) +" "+ this.planes[BOTTOM].w.toFixed(3));

		/*
		* TOP
		*/
	  this.planes[TOP].x = -this.VPmatrix.get(0,1) + this.VPmatrix.get(0,3);
	  this.planes[TOP].y = -this.VPmatrix.get(1,1) + this.VPmatrix.get(1,3);
	  this.planes[TOP].z = -this.VPmatrix.get(2,1) + this.VPmatrix.get(2,3);
	  // this.planes[TOP].w = -this.VPmatrix.get(3,1) + this.VPmatrix.get(3,3);

		// this.planes[TOP] = this.planes[TOP].nor();

		d[TOP] =  -this.VPmatrix.get(3,1) + this.VPmatrix.get(3,3) //+  ;;
		//
		// if(this.planes[TOP].len() > 0)
		// 	d[TOP] = d[TOP]/this.planes[TOP].len();
		//
		// this.planes[TOP].w = d[TOP] //+ camPos.y ;
		//
		// console.log("TOP"+"\t"+this.planes[TOP].x.toFixed(3) +" "+ this.planes[TOP].y.toFixed(3) +" "+ this.planes[TOP].z.toFixed(3) +" "+ this.planes[TOP].w.toFixed(3));

		/*
		* NEAR
		*/
	  this.planes[NEAR].x = this.VPmatrix.get(0,2) + this.VPmatrix.get(0,3);
	  this.planes[NEAR].y = this.VPmatrix.get(1,2) + this.VPmatrix.get(1,3);
	  this.planes[NEAR].z = this.VPmatrix.get(2,2) + this.VPmatrix.get(2,3);
	  // this.planes[NEAR].w = this.VPmatrix.get(3,2) //+ this.VPmatrix.get(3,3);

		// this.planes[NEAR] = this.planes[NEAR].nor();

		d[NEAR] =  this.VPmatrix.get(3,2) + this.VPmatrix.get(3,3) ;;
		//
		// if(this.planes[NEAR].len() > 0)
		// 	d[NEAR] = d[NEAR]/this.planes[NEAR].len();
		//
		// this.planes[NEAR].w = d[NEAR] //+ camPos.z ;
		//
		// console.log("NEAR"+"\t"+this.planes[NEAR].x.toFixed(3) +" "+ this.planes[NEAR].y.toFixed(3) +" "+ this.planes[NEAR].z.toFixed(3) +" "+ this.planes[NEAR].w.toFixed(3));

		/*
		* FAR
		*/
	  this.planes[FAR].x = -this.VPmatrix.get(0,2) + this.VPmatrix.get(0,3);
	  this.planes[FAR].y = -this.VPmatrix.get(1,2) + this.VPmatrix.get(1,3);
	  this.planes[FAR].z = -this.VPmatrix.get(2,2) + this.VPmatrix.get(2,3);
	  // this.planes[FAR].w = -this.VPmatrix.get(3,2) + this.VPmatrix.get(3,3);

		// this.planes[FAR] = this.planes[FAR].nor();

		d[FAR] =  -this.VPmatrix.get(3,2) + this.VPmatrix.get(3,3) //+  ;;
		//
		// if(this.planes[FAR].len() > 0)
		// 	d[FAR] = d[FAR]/this.planes[FAR].len();
		//
		// this.planes[FAR].w = d[FAR] //+ camPos.z ;
		//
		// console.log("FAR"+"\t"+this.planes[FAR].x.toFixed(3) +" "+ this.planes[FAR].y.toFixed(3) +" "+ this.planes[FAR].z.toFixed(3) +" "+ this.planes[FAR].w.toFixed(3));



		// console.log(camPos);

		// var str = ["LEFT","RIGHT","BOTTOM","TOP","NEAR","FAR"];
		// var delta = [camPos.x,camPos.x,camPos.y,camPos.y,camPos.z,camPos.z];

	    for (var i = 0; i < this.planes.length; i++) {



				if(this.planes[i].len() > 0){

					// console.log(d[i] + "/"+ this.planes[i].len() + "=" +d[i]/this.planes[i].len());

					d[i] = d[i]/this.planes[i].len();


					this.planes[i] = this.planes[i].nor();

					this.planes[i].w = d[i]//+delta[i];
				}


				// console.log(str[i]+"\t"+this.planes[i].x.toFixed(3) +" "+ this.planes[i].y.toFixed(3) +" "+ this.planes[i].z.toFixed(3) +" "+ this.planes[i].w.toFixed(3));

	    }
		}
};

//----------------------------------------------------------------------
var Camera = function (matrix){
	Component.call(this);
	this.target = null;
	this.projectionMatrix = matrix;
	this.frustum = new Frustum(this);
	this.viewMatrix = Matrix4.identity();
};

Camera.prototype = new Component();
Camera.prototype.constructor = Camera;

//----------------------------------------------------------------------

Camera.prototype.getFrustum = function (){
	return this.frustum;
};

//----------------------------------------------------------------------

Camera.prototype.setProjection = function (projectionMatrix){
    this.projectionMatrix = projectionMatrix;
};

//----------------------------------------------------------------------

Camera.prototype.getProjectionMatrix = function (){
    return this.projectionMatrix;
};

//----------------------------------------------------------------------

Camera.prototype.getViewMatrix = function (){

	var t = this.gameObject.getTransform();

	if(t.isDirty()){
		this.viewMatrix = new Matrix4(
	        t.right,
	        t.up,
	        t.forward,
	        new Vector4(0,0,0,1));

		this.viewMatrix = Matrix4.mulMM( Matrix4.translation(t.position.cpy().mulScl(-1)),this.viewMatrix);

		// viewMatrix.print()
	}


	return this.viewMatrix;
};

//----------------------------------------------------------------------
var OrthoCamera = function (left, right, bottom, top, near, far){
	Camera.call(this,Matrix4.ortho(left, right, bottom, top, near, far));

    this.left = left;
    this.right = right;
    this.bottom = bottom;
    this.top = top;
    this.near = near;
    this.far = far;

};

OrthoCamera.prototype = new Camera();
OrthoCamera.prototype.constructor = OrthoCamera;

//----------------------------------------------------------------------
var PerspectiveCamera = function (near, far, aspect, fov){
	Camera.call(this,Matrix4.perspective(near, far, aspect, fov));

	this.near = near;
	this.far = far;
	this.aspect = aspect;
	this.fov = fov;
};

PerspectiveCamera.prototype = new Camera();
PerspectiveCamera.prototype.constructor = PerspectiveCamera;

//----------------------------------------------------------------------
var Time = function () {

};

Time.lastTime = 0.0;
Time.delta = 0.0;
Time.deltaInSeconds = 0.0;
Time.lastTimeInSeconds = 0.0;

//----------------------------------------------------------------------

Time.init = function () {
    Time.lastTime = Date.now();
};

//----------------------------------------------------------------------

Time.tick = function () {
    var now = Date.now();

    Time.delta = now-Time.lastTime;
    Time.deltaInSeconds = Time.delta/1000;

    Time.lastTime = now;
    Time.lastTimeInSeconds = Time.lastTime/1000;
};

//----------------------------------------------------------------------

// This time is the same for the whole frame (engine loop).
// This allows synchronize the animations !!!!
Time.now = function () {
    return Time.lastTimeInSeconds;
};

//----------------------------------------------------------------------

Time.deltaTime = function () {
    return Time.deltaInSeconds;
};

//----------------------------------------------------------------------
var Engine = function (){
  this.renderEngine = null;
  this.physicsEngine = null;
  this.scriptEngine = null;
  this.currentScene = null;
  this.scenes = {};
  this.input = new Input();

  this.loaded = false;
  this.physicsEnabled = true;
};

//----------------------------------------------------------------------

// TODO: Singleton

Engine.prototype.getCurrentScene = function (){
	return this.currentScene;
};

//----------------------------------------------------------------------

Engine.prototype.addScene = function (currentScene){
	this.scenes[currentScene.getName()] = currentScene;
};

//----------------------------------------------------------------------

Engine.prototype.setCurrentScene = function (name){

  if(this.currentScene !== null)
    this.currentScene.setLoaded(false); // reset

	this.currentScene=this.scenes[name];
};

//----------------------------------------------------------------------

Engine.prototype.getScenes = function (){
	return this.scenes;
};

//----------------------------------------------------------------------

Engine.prototype.setClearColor = function (color){
  this.renderEngine.setClearColor(color);
};

//----------------------------------------------------------------------

Engine.prototype.enablePhysics = function (){
  this.physicsEnabled = true;
};

//----------------------------------------------------------------------

Engine.prototype.disablePhysics = function (){
  this.physicsEnabled = false;
};

//----------------------------------------------------------------------

Engine.prototype.init = function (){

  this.renderEngine = new RenderEngine();
  this.physicsEngine = new PhysicsEngine();
  this.scriptEngine = new ScriptEngine();

};

//----------------------------------------------------------------------

Engine.prototype.uploadScene = function(){

  var root = this.currentScene.getNewsRoot();

  var renderers = root.getComponentsInChildren(MeshRenderer);
  var rigidBodies = root.getComponentsInChildren(RigidBody);
  var scripts = root.getComponentsInChildren(Script);

  this.currentScene.setLoaded(true);
  this.currentScene.flush();

  this.renderEngine.addRenderers(renderers);
  this.renderEngine.setRenderContext(this.currentScene.getRenderContext());

  this.physicsEngine.addBodies(rigidBodies);

  this.scriptEngine.addScripts(scripts);

};

//----------------------------------------------------------------------

Engine.prototype.loadScene = function(){

  this.renderEngine.clear();
  this.physicsEngine.clear();
  this.scriptEngine.clear();

  this.uploadScene();

};

//----------------------------------------------------------------------



Engine.prototype.run = function () {

  // window.requestAnimFrame = (function(){
  //   return  window.requestAnimationFrame       ||
  //           window.webkitRequestAnimationFrame ||
  //           window.mozRequestAnimationFrame    ||
  //           function( callback ){
  //             window.setTimeout(callback, 1000 / 30);
  //           };
  // })();


  var renderEngine = this.renderEngine;
  var physicsEngine = this.physicsEngine;
  var scriptEngine = this.scriptEngine;
  var currentScene = this.currentScene;

  var engine = this;

  var max = 0;

  // this.binded = false;

  var main = function () {

    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);

    if(! currentScene.isLoaded())
      engine.loadScene();

    if(currentScene.hasNewObjects())
      engine.uploadScene();

    if(Loader.isDone()){
      engine.loaded = true;
      renderEngine.bind();
      Loader.reset();
    }

    if(engine.loaded){
      scriptEngine.update();

      if(engine.physicsEnabled)
        physicsEngine.update();

      renderEngine.update();
      renderEngine.render();
    }

    Time.tick();
  };

  // var render = function () {
  //     window.requestAnimFrame(render);
  //     if(this.binded){
  //         renderEngine.render();
  //     }
  // }

  Time.init();

  // render();


  var ONE_FRAME_TIME = 1000.0 / 30.0 ;
  setInterval( main, ONE_FRAME_TIME );
};

//----------------------------------------------------------------------
var Loader = function (){

};

Loader.images = {};
Loader.textures = {};
Loader.materials = {};

Loader.requests = 0;
Loader.loaded = 0;
Loader.done = false;
Loader.hasImageRequests = false;
// Loader.running = false;

// TODO: Loader.LoadTextFile(path) ==> The text file will be included
// within a div element like this ==> <div id=path> plain text </div>

//----------------------------------------------------------------------

Loader.isDone = function(){

    if( ! Loader.hasImageRequests)
        return true;

    return Loader.done;
};

//----------------------------------------------------------------------

Loader.reset = function(){
  Loader.done = false;
};

//----------------------------------------------------------------------

Loader.loadImageFile = function (path){

    Loader.hasImageRequests = true;

    if((path in Loader.images)){
        return Loader.images[path];

    }else{
        Loader.requests++;
        var img = new Image();

        Loader.images[path] = img;

        img.src = path; // DOWNLOADING!

        img.onload = function(){
            Loader.loaded++;
            if(Loader.requests == Loader.loaded)
                Loader.done = true;
            else
                Loader.done = false;
        };

        return Loader.images[path];
    }

};

//----------------------------------------------------------------------

Loader.loadTexture = function (path) {
    if( ! (path in Loader.textures)){
        var img = Loader.loadImageFile(path);

        var texture = new Texture(path,img);
        Loader.textures[path] = texture;
    }

    return Loader.textures[path];
};

//----------------------------------------------------------------------
var Input = function (){

    var onKeyDown = function(event){

        Input.key = event.keyCode;

        // this allow reload page with F5
        // if(event.keyCode !== 116)
        //     event.preventDefault();

    };

    var onKeyUp = function(event){

        Input.key = -1;

        // event.preventDefault();

    };

    var onMouseMove = function(event){

      var canvas = document.getElementById("glcanvas");


        Input.cursorPos.x = event.clientX;
        Input.cursorPos.y = event.clientY * -1;

        Input.cursorPos.x -= canvas.width/2;
        Input.cursorPos.y += canvas.height/2;


        // event.preventDefault();

    };

    var onMouseDown = function(event){

        // Input.cursorPos.x = event.clientX;
        // Input.cursorPos.y = event.clientY;
        Input.button = event.button;

        // event.preventDefault();

    };

    var onMouseUp = function(event){

        // Input.cursorPos.x = event.clientX;
        // Input.cursorPos.y = event.clientY;
        Input.button = -1;

        // event.preventDefault();

    };

    document.addEventListener("keydown", onKeyDown,false);
    document.addEventListener("keyup", onKeyUp,false);

    var canvas = document.getElementById("glcanvas");
    canvas.addEventListener("mousedown", onMouseDown,false);
    canvas.addEventListener("mouseup", onMouseUp,false);
    canvas.addEventListener("mousemove", onMouseMove,false);

    canvas.addEventListener("contextmenu", function(event){
        event.preventDefault();
        return false;
    },false);

};

Input.key = -1;
Input.button = -1;

Input.cursorPos = new Vector2(0,0);

//----------------------------------------------------------------------

Input.getKey = function (){
	return Input.key;
};

//----------------------------------------------------------------------

Input.getButton = function (){
	return Input.button;
};

//----------------------------------------------------------------------

Input.getCursorPosition = function (){

	return Input.cursorPos;
};

//----------------------------------------------------------------------

// TODO: Implement input stack, implement key codes, char?
var Log = function (){
    this.text="";
};

//----------------------------------------------------------------------

Log.prototype.print = function (string){
    this.text += string;
};

//----------------------------------------------------------------------

Log.prototype.println = function (string){
    this.text += string + "\n";
};

//----------------------------------------------------------------------

Log.prototype.getStr = function () {
    return this.text;
};

//----------------------------------------------------------------------
var Debug = function (){

};

// TODO: Use the Time.js class

Debug.log = new Log();

// RENDER VARIABLES
Debug.renderTotalCalls = 0;

Debug.renderTotalTime = 0;
Debug.renderLastDeltaTime = 0;
Debug.renderAverageDeltaTime = 0;

Debug.renderBeginTime = 0;

//----------------------------------------------------------------------

Debug.beginRender = function() {
    Debug.renderBeginTime = Date.now();
    Debug.renderTotalCalls += 1;
};

//----------------------------------------------------------------------

Debug.endRender = function() {
    Debug.renderLastDeltaTime = Date.now() - Debug.renderBeginTime;
    Debug.renderTotalTime += Debug.renderLastDeltaTime;
    Debug.renderAverageDeltaTime = Debug.renderTotalTime/Debug.renderTotalCalls;
};

//----------------------------------------------------------------------

Debug.print = function() {
    console.log("RENDER");
    console.log("TOTAL CALLS: " + Debug.renderTotalCalls);
    console.log("TOTAL TIME: " + Debug.renderTotalTime);
    console.log("AVERAGE: " + Debug.renderAverageDeltaTime);
};

//----------------------------------------------------------------------
var Script = function (){
    Component.call(this);
};

Script.prototype = new Component();
Script.prototype.constructor = Script;

//----------------------------------------------------------------------

Script.prototype.start = function (){
  throw new Error("Abstract method!");
};

//----------------------------------------------------------------------

Script.prototype.update = function (){
  var children = this.getChildren();
	for (var i = 0; i < children.length; i++) {
	   children[i].update();
	}
};


// ... onCollision, onDestroy, etc.

//----------------------------------------------------------------------
var ScriptEngine = function (){
  this.scripts = [];
};

//----------------------------------------------------------------------

ScriptEngine.prototype.getScripts = function (){
	return this.scripts;
};

//----------------------------------------------------------------------

ScriptEngine.prototype.addScripts = function (scripts){
  for (var i = 0; i < scripts.length; i++) {
    scripts[i].start();
    this.scripts.push(scripts[i]);
	}
};

//----------------------------------------------------------------------

ScriptEngine.prototype.clear = function (){
	this.scripts = [];
};

//----------------------------------------------------------------------

ScriptEngine.prototype.update = function (){
    for (script of this.scripts)
        script.update();

};

//----------------------------------------------------------------------
var Random = function(seed){
    this.seed = seed;
};

//----------------------------------------------------------------------

// http://programmers.stackexchange.com/questions/260969/original-source-of-seed-9301-49297-233280-random-algorithm

Random.prototype.seededRandom = function(max, min) {


    this.seed = (this.seed * 9301 + 49297) % 233280;
    var rnd = this.seed / 233280;

    return rnd;
};

//----------------------------------------------------------------------
var PerlinNoise = function(n,seed){

    this.random = new Random(seed);
    this.n = n;
    // this.posOffset = posOffset.cpy();

    this.gradients = new Array(this.n);

    // -------------------------------

    // Shuffle function
    function shuffle(array, randomGenerator) {

      var currentIndex = array.length;
      var aux;
      var randomIndex;

      while (currentIndex !== 0) {
        // Pick a remaining element...
        randomIndex = Math.floor(randomGenerator.seededRandom() * currentIndex);
        currentIndex -= 1; // lenght--

        // swap
        aux = array[currentIndex];
        array[currentIndex] = array[randomIndex];
        array[randomIndex] = aux;
      }

      return array;
    }

    // -------------------------------

    // Gradients array
    for ( var i=0; i<this.n; i++) {
      this.gradients[ i ] = new Vector2(0,0);

      this.gradients[ i ].x = this.random.seededRandom() * 2.0 - 1.0;
      this.gradients[ i ].y = this.random.seededRandom() * 2.0 - 1.0;

      var lengthSq = this.gradients[ i ].x * this.gradients[ i ].x + this.gradients[ i ].y * this.gradients[ i ].y;
      var length = Math.sqrt( lengthSq );

      this.gradients[ i ].x /= length;
      this.gradients[ i ].y /= length;
    }

    // -------------------------------

    // Permutations array
    this.permutation = new Array(this.n);

    for (var i = 0; i < this.n; i++)
        this.permutation.push(i);

    this.permutation = shuffle(this.permutation, this.random);

    // -------------------------------
};

//----------------------------------------------------------------------

PerlinNoise.prototype.getGradient = function( point ){
    // TODO: use & or mod % ????

    var index = point.y  & (this.n - 1);
    index = ( point.x + this.permutation[ index ] ) & (this.n - 1);

    return this.gradients[ index ];
};

//----------------------------------------------------------------------

PerlinNoise.prototype.lerp = function(a, b, t) {
     return (1.0 - t)*a + t*b;
};

//----------------------------------------------------------------------

// Computes the dot product of the distance and gradient vectors.
PerlinNoise.prototype.dotGridGradient = function(ix, iy, x, y) {

  // Compute the distance vector
  var offset = new Vector2(x - ix, y - iy);

  var grad = this.getGradient(new Vector2(ix,iy));

  // Compute the dot-product
  return grad.dot(offset);
};

//----------------------------------------------------------------------

PerlinNoise.prototype.generate = function(x, y){

  x += this.random.seededRandom(); // in [0,1] range
  y += this.random.seededRandom(); // in [0,1] range

  var xCoord = Math.floor(x);
  var yCoord = Math.floor(y);

  // Determine grid cell coordinates
  var x0 = (xCoord > 0.0 ? xCoord : xCoord - 1);
  var x1 = x0 + 1;
  var y0 = (yCoord > 0.0 ? yCoord : yCoord - 1);
  var y1 = y0 + 1;

  // Determine interpolation weights
  // Could also use higher order polynomial/s-curve here
  var sx = xCoord - x0;
  var sy = yCoord - y0;

  // Interpolate between grid point gradients
  var n0, n1, ix0, ix1, value;

  n0 = this.dotGridGradient(x0, y0, x, y);
  n1 = this.dotGridGradient(x1, y0, x, y);
  ix0 = this.lerp(n0, n1, sx);
  n0 = this.dotGridGradient(x0, y1, x, y);
  n1 = this.dotGridGradient(x1, y1, x, y);
  ix1 = this.lerp(n0, n1, sx);

  // console.log(ix0);
  // console.log(ix1);
  value = this.lerp(ix0, ix1, sy);

  // console.log(value);

  return value;
};

//----------------------------------------------------------------------
var GameObjectBuilder = function (){
  this.tmpObj = null;
};

//----------------------------------------------------------------------

GameObjectBuilder.empty = function () {
  var obj = new GameObject();

  var transform = new Transform();
  obj.addComponent(transform);

  return obj;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.begin = function () {
  this.tmpObj = GameObjectBuilder.empty();
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setStatic = function (bool){
 this.tmpObj.setStatic(bool);
 return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setTransform = function (transform) {
  obj.addComponent(transform);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setPosition = function (vec){
  this.tmpObj.getTransform().setPosition(vec);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setRotation = function (vec){
  this.tmpObj.getTransform().setRotation(vec);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setScale = function (vec){
  this.tmpObj.getTransform().setScale(vec);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setRigidBody = function (){
  var rigidBody = new RigidBody();
  this.tmpObj.addComponent(rigidBody);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setCollider = function (collider){
  this.tmpObj.addComponent(collider);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setRenderer = function (renderer) {
  this.tmpObj.addComponent(renderer);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setMesh = function (mesh) {
  this.tmpObj.getComponent(MeshRenderer).setMesh(mesh);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setMaterial = function (material) {
  this.tmpObj.getComponent(MeshRenderer).setMaterial(material);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setColor = function (color) {
  this.tmpObj.getComponent(MeshRenderer).getMaterial().setColor(color);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setAlphaColor = function (color) {
  this.tmpObj.getComponent(MeshRenderer).setAlphaColor(color);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setTextureRegion = function (texCoord, width, height) {
  this.tmpObj.getComponent(MeshRenderer).setRegion(texCoord, width, height);
  return this;
};

//----------------------------------------------------------------------

/**
 * horizontalDir: -1 -> left, 1 -> right, 0 -> not move
 * verticalDir: -1 -> down, 1 -> up, 0 -> not move
 */
GameObjectBuilder.prototype.addAnimation = function (name, frameCount, horizontal, reverse, startPosition, width, height, speed) {

  var animation = Animation.create(frameCount, horizontal, reverse, startPosition, width, height, speed);

  this.tmpObj.getComponent(MeshRenderer).addAnimation(name,animation);

  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.setAnimation = function (name) {

  this.tmpObj.getComponent(MeshRenderer).setAnimation(name);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.addScript = function (script) {
  this.tmpObj.addComponent(script);
  return this;
};

//----------------------------------------------------------------------

GameObjectBuilder.prototype.end = function () {
  return this.tmpObj;
};

//----------------------------------------------------------------------
var SpriteBuilder = function (){
  GameObjectBuilder.call(this);
};

SpriteBuilder.prototype = new GameObjectBuilder();
SpriteBuilder.prototype.constructor = SpriteBuilder;

//----------------------------------------------------------------------

SpriteBuilder.prototype.begin = function (textureName) {
  GameObjectBuilder.prototype.begin.call(this);

  this.setRenderer(new SpriteRenderer());

  var material = new Material();
  if(textureName !== null && textureName !== "")
    material.setTexture(Loader.loadTexture(textureName));

  this.setMaterial(material);

  return this;
};

//----------------------------------------------------------------------

SpriteBuilder.prototype.setSize = function (size) {
  this.setScale(new Vector2(size,size));
  return this;
};

//----------------------------------------------------------------------
var CameraBuilder = function (){
  GameObjectBuilder.call(this);
};

CameraBuilder.prototype = new GameObjectBuilder();
CameraBuilder.prototype.constructor = CameraBuilder;

//----------------------------------------------------------------------

CameraBuilder.prototype.setOrtho = function (w,h,far,near) {

  // TODO: implement zoom into OrthoCamera class.
  this.cam = new OrthoCamera(-w,w,-h,h, far,near);
  this.tmpObj.addComponent(this.cam);

  return this;
};

//----------------------------------------------------------------------

CameraBuilder.prototype.setPerspective = function (far,near,aspect,fov) {

  this.cam = new PerspectiveCamera(far,near,aspect,fov);
  this.tmpObj.addComponent(this.cam);

  return this;
};

//----------------------------------------------------------------------
var Thief = function() {

};

Thief.engine = null;
Thief.currentScene = null;

//----------------------------------------------------------------------

Thief.init = function () {
  Thief.engine = new Engine();
  Thief.engine.init();
};

//----------------------------------------------------------------------

Thief.empty = function () {
  var obj = new GameObject();

  var transform = new Transform();
  obj.addComponent(transform);

  return obj;
};

//----------------------------------------------------------------------

Thief.setClearColor = function (color) {
  Thief.engine.setClearColor(color);
};

//----------------------------------------------------------------------

Thief.enablePhysics = function () {
  Thief.engine.enablePhysics();
};

//----------------------------------------------------------------------

Thief.disablePhysics = function () {
  Thief.engine.disablePhysics();
};

//----------------------------------------------------------------------

Thief.run = function () {
  Thief.engine.run();
};

//----------------------------------------------------------------------

Thief.createScene = function (name) {
  Thief.currentScene = new Scene(name);
  Thief.engine.addScene(this.currentScene);
};

//----------------------------------------------------------------------

Thief.setScene = function (name) {
  Thief.engine.setCurrentScene(name);
};

//----------------------------------------------------------------------

Thief.getScene = function () {
  return Thief.engine.getCurrentScene();
};

//----------------------------------------------------------------------

Thief.createAndSetScene = function (name) {
  Thief.createScene(name);
  Thief.setScene(name);
};

//----------------------------------------------------------------------

Thief.setCamera = function (obj) {
  var renderContext = new RenderContext();

  renderContext.setCamera(obj.getComponent(Camera));

  Thief.getScene().setRenderContext(renderContext);

  Thief.currentScene.addObject(obj);
};

//----------------------------------------------------------------------

Thief.addGameObjectToScene = function (obj) {
  Thief.currentScene.addObject(obj);
};

//----------------------------------------------------------------------
